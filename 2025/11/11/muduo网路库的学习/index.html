
  <!DOCTYPE html>
  <html lang="zh-CN"  >
  <head>
  <meta charset="utf-8">
  

  

  

  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_tq6stt6tcg';window.REIMU_CONFIG.clipboard_tips = {"success":"复制成功(*^▽^*)","fail":"复制失败 (ﾟ⊿ﾟ)ﾂ","copyright":{"enable":false,"count":50,"content":"本文版权：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！"}};window.REIMU_CONFIG.code_block = {"expand":true};</script>
  
  <title>
    muduo网路库的学习 |
    
    NILV的博客
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media&#x3D;&#39;all&#39;">
  
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_tq6stt6tcg.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  
  
    
<link rel="stylesheet" href="/css/loader.css">

  
  
    <meta name="description" content="项目核心组件关系与数据流向图核心框架：Reactor 模型（one loop per thread），核心流转是「事件触发→组件协作→数据处理」，所有组件围绕 “高效处理网络 IO” 联动。 核心组件关联总览12345[客户端] ↔ [Socket] ↔ [Channel] ↔ [Poller] ↔ [EventLoop]                          ↑">
<meta property="og:type" content="article">
<meta property="og:title" content="muduo网路库的学习">
<meta property="og:url" content="http://example.com/2025/11/11/muduo%E7%BD%91%E8%B7%AF%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="NILV的博客">
<meta property="og:description" content="项目核心组件关系与数据流向图核心框架：Reactor 模型（one loop per thread），核心流转是「事件触发→组件协作→数据处理」，所有组件围绕 “高效处理网络 IO” 联动。 核心组件关联总览12345[客户端] ↔ [Socket] ↔ [Channel] ↔ [Poller] ↔ [EventLoop]                          ↑">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-11T09:58:18.758Z">
<meta property="article:modified_time" content="2025-11-24T14:09:50.612Z">
<meta property="article:author" content="nilv">
<meta name="twitter:card" content="summary">
  
  
    <link rel="alternate" href="/atom.xml" title="NILV的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  
  
  
  
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

  
  
    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.0/dist/aos.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    
  <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi">
        
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
        
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var startLoading = () => {
      time = Date.now();
      document.getElementById('loader').classList.remove("loading");
    }
    var endLoading = () => {
      if (!time) {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
      } else {
        if (Date.now() - time > 500) {
          time = null;
          document.body.style.overflow = 'auto';
          document.getElementById('loader').classList.add("loading");
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    document.getElementById('loader').addEventListener('click', endLoading);
  </script>

<div id="copy-tooltip" style="pointer-events: none; opacity: 0; transition: all 0.2s ease; position: fixed;top: 50%;left: 50%;z-index: 999;transform: translate(-50%, -50%);color: white;background: rgba(0, 0, 0, 0.5);padding: 10px 15px;border-radius: 10px;">
</div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav">
    
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/">首页</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/archives">归档</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/about">关于</a>
        </span>
      
        <span class="main-nav-link-wrap">
          <div class="main-nav-icon icon rotate">
            &#xe62b;
          </div>
          <a class="main-nav-link" href="/friend">友链</a>
        </span>
      
    
    <a id="main-nav-toggle" class="nav-icon"></a>
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" target="_blank"></a>
    
    
    
  </nav>
</div>
<header id="header">
  
    
      <img fetchpriority="high" src="/images/banner.webp" alt="muduo网路库的学习">
    
  
  <div id="header-outer">
    <div id="header-title">
      
        
        
          <a href="/" id="logo">
            <h1 data-aos="slide-up">muduo网路库的学习</h1>
          </a>
        
      
      
        
        <h2 id="subtitle-wrap" data-aos="slide-down">
          
        </h2>
      
    </div>
  </div>
</header>

        <div id="content">
          
          <section id="main"><article id="post-muduo网路库的学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <a href="/2025/11/11/muduo%E7%BD%91%E8%B7%AF%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="article-date-link" data-aos="zoom-in">
    <time datetime="2025-11-11T09:58:18.758Z" itemprop="datePublished">2025-11-11</time>
    <time style="display: none;" id="post-update-time">2025-11-24</time>
  </a>
</div>

      

    </div>
    <div class="hr-line"></div>
    

    <div class="e-content article-entry" itemprop="articleBody">
      
      
        <h1 id="项目核心组件关系与数据流向图"><a href="#项目核心组件关系与数据流向图" class="headerlink" title="项目核心组件关系与数据流向图"></a>项目核心组件关系与数据流向图</h1><p>核心框架：<strong>Reactor 模型</strong>（one loop per thread），核心流转是「事件触发→组件协作→数据处理」，所有组件围绕 “高效处理网络 IO” 联动。</p>
<h2 id="核心组件关联总览"><a href="#核心组件关联总览" class="headerlink" title="核心组件关联总览"></a>核心组件关联总览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[客户端] ↔ [Socket] ↔ [Channel] ↔ [Poller] ↔ [EventLoop]</span><br><span class="line">                          ↑</span><br><span class="line">                  [Acceptor]（主循环专属）</span><br><span class="line">                          ↑</span><br><span class="line">[TcpServer] → [TcpConnection] ↔ [Buffer]（读写数据载体）</span><br></pre></td></tr></table></figure>

<p>总结下来，流程就是：服务器启动（loop 启动） → Acceptor 监听端口 → 客户端连接触发读事件 → handleRead 接收 connfd 并交给 TcpConnection → Buffer 读写数据 → 业务层处理数据&#x2F;返回响应。</p>
<h1 id="项目前置工具实现细节"><a href="#项目前置工具实现细节" class="headerlink" title="项目前置工具实现细节"></a>项目前置工具实现细节</h1><h2 id="noncopyable-类"><a href="#noncopyable-类" class="headerlink" title="noncopyable 类"></a>noncopyable 类</h2><p>C++ 中， 默认情况下所有的类都支持拷贝和构造， 有些对象逻辑上不应该被复制，<br>例如本项目的的 Eventloop（事件循环， 一个线程只能有一个），<br>Socket, Acceptor 复制会导致fd重复关闭， 所以需要这样的一个基类</p>
<p>noncopyable 核心作用是进制派生类对象被拷贝或赋值<br>通过删除拷贝构造函数和拷贝赋值运算符，确保继承它的类（派生类）无法被复制或赋值，<br>从而避免因对象拷贝导致的资源管理问题（如重复释放、资源不一致等）。</p>
<p>代码实现细节</p>
<p><strong>noncopyable.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma once // 预处理指令，防止头文件重复包含</span><br><span class="line"></span><br><span class="line">class noncopyable &#123;</span><br><span class="line">public:</span><br><span class="line">    // 禁止这两类常见的拷贝操作</span><br><span class="line">    noncopyable(const noncopyable &amp;) = delete;</span><br><span class="line">    noncopyable &amp;operator = (const noncopyable &amp;) = delete;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">// 将构造函数声明为 protected（受保护的），意味着只有它的派生类（子类）才能访问。</span><br><span class="line">// 这就防止了用户直接创建 noncopyable </span><br><span class="line">// 类的实例（因为在类外部无法调用 protected 的构造函数），符合其作为基类的设计初衷。</span><br><span class="line">    noncopyable() = default;</span><br><span class="line">    ~noncopyable() = default;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><p>为了 统一日志格式、简化日志输出、支持级别过滤和调试开关<br>我们需要一个日志工具</p>
<p>实现一个日志核心类 logger， 单例 + 不可复制</p>
<p>日志级别枚举<br>四种日志级别，区分日志重要程度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum LogLevel &#123;</span><br><span class="line">    INFO,  // 普通信息（如程序启动、连接建立）</span><br><span class="line">    ERROR, // 错误信息（如连接失败、读写超时，不影响程序运行）</span><br><span class="line">    FATAL, // 致命错误（如绑定端口失败、内存分配失败，程序必须退出）</span><br><span class="line">    DEBUG, // 调试信息（如变量值、函数调用流程，仅开发阶段启用）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>日志输出宏定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define LOG_INFO(logmsgFormat, ...)                       \</span><br><span class="line">    do                                                    \</span><br><span class="line">    &#123;                                                     \</span><br><span class="line">        Logger &amp;logger = Logger::instance();              \</span><br><span class="line">        logger.setLogLevel(INFO);                         \</span><br><span class="line">        char buf[1024] = &#123;0&#125;;                             \</span><br><span class="line">        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \</span><br><span class="line">        logger.log(buf);                                  \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>#define LOG_INFO(logmsgFormat, …)：宏定义的参数列表；<br>logmsgFormat：日志格式化字符串（如 “bind sockfd:%d fail”）；<br>…：可变参数（对应格式化字符串中的占位符，如 %d 对应的 sockfd_）；<br>##__VA_ARGS__：C99 语法，将可变参数传递给 snprintf，## 确保 “无可变参数时也能编译通过”（避免语法错误）。</p>
<p>do-while(0) 包裹，避免 在 if-else 等语句中因缺少大括号导致逻辑错误</p>
<p>日志核心类的实现</p>
<p><strong>Logger.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">enum LogLevel &#123;</span><br><span class="line">    INFO,  // 普通信息（如程序启动、连接建立）</span><br><span class="line">    ERROR, // 错误信息（如连接失败、读写超时，不影响程序运行）</span><br><span class="line">    FATAL, // 致命错误（如绑定端口失败、内存分配失败，程序必须退出）</span><br><span class="line">    DEBUG, // 调试信息（如变量值、函数调用流程，仅开发阶段启用）</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define LOG_INFO(logmsgFormat, ...)                       \</span><br><span class="line">    do                                                    \</span><br><span class="line">    &#123;                                                     \</span><br><span class="line">        Logger &amp;logger = Logger::instance();              \</span><br><span class="line">        logger.setLogLevel(INFO);                         \</span><br><span class="line">        char buf[1024] = &#123;0&#125;;                             \</span><br><span class="line">        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \</span><br><span class="line">        logger.log(buf);                                  \</span><br><span class="line">    &#125; while (0)</span><br><span class="line"></span><br><span class="line">#define LOG_ERROR(logmsgFormat, ...)                       \</span><br><span class="line">    do                                                    \</span><br><span class="line">    &#123;                                                     \</span><br><span class="line">        Logger &amp;logger = Logger::instance();              \</span><br><span class="line">        logger.setLogLevel(ERROR);                         \</span><br><span class="line">        char buf[1024] = &#123;0&#125;;                             \</span><br><span class="line">        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \</span><br><span class="line">        logger.log(buf);                                  \</span><br><span class="line">    &#125; while (0)</span><br><span class="line"></span><br><span class="line">#define LOG_FATAL(logmsgFormat, ...)                       \</span><br><span class="line">    do                                                    \</span><br><span class="line">    &#123;                                                     \</span><br><span class="line">        Logger &amp;logger = Logger::instance();              \</span><br><span class="line">        logger.setLogLevel(FATAL);                         \</span><br><span class="line">        char buf[1024] = &#123;0&#125;;                             \</span><br><span class="line">        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \</span><br><span class="line">        logger.log(buf);                                  \</span><br><span class="line">    &#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 1. 编译开关判断：是否定义了 MUDEBUG 宏</span><br><span class="line">#ifdef MUDEBUG</span><br><span class="line">// 2. 若定义（调试模式）：定义 LOG_DEBUG 宏，执行日志输出逻辑</span><br><span class="line">#define LOG_DEBUG(logmsgFormat, ...)                      \</span><br><span class="line">    do                                                    \</span><br><span class="line">    &#123;                                                     \</span><br><span class="line">        Logger &amp;logger = Logger::instance();              \</span><br><span class="line">        logger.setLogLevel(DEBUG);                        \</span><br><span class="line">        char buf[1024] = &#123;0&#125;;                             \</span><br><span class="line">        snprintf(buf, 1024, logmsgFormat, ##__VA_ARGS__); \</span><br><span class="line">        logger.log(buf);                                  \</span><br><span class="line">    &#125; while (0)</span><br><span class="line">#else</span><br><span class="line">// 3. 若未定义（发布模式）：定义 LOG_DEBUG 宏为空，不执行任何操作</span><br><span class="line">#define LOG_DEBUG(logmsgFormat, ...)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">class Logger : noncopyable &#123;</span><br><span class="line">public:</span><br><span class="line">    // 获取日志唯一的实例对象</span><br><span class="line">    static Logger &amp;instance();</span><br><span class="line"></span><br><span class="line">    // 设置日志等级</span><br><span class="line">    void setLogLevel(int level);</span><br><span class="line"></span><br><span class="line">    // 写日志</span><br><span class="line">    void log(std::string msg);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int logLevel_; // 日志等级</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Logger.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;Logger.h&quot;</span><br><span class="line">#include &quot;Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">// 获取日志唯一的实例对象 单例</span><br><span class="line">Logger &amp;Logger::instance() &#123;</span><br><span class="line">    static Logger logger;</span><br><span class="line">    return logger;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置日志级别</span><br><span class="line">void Logger::setLogLevel(int level) &#123;</span><br><span class="line">    logLevel_ = level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写日志 [级别信息] time : msg</span><br><span class="line">void Logger::log(std::string msg) &#123;</span><br><span class="line">    std::string pre = &quot;&quot;;</span><br><span class="line">    switch (logLevel_)</span><br><span class="line">    &#123;</span><br><span class="line">    case INFO:</span><br><span class="line">        pre = &quot;[INFO]&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case ERROR:</span><br><span class="line">        pre = &quot;[ERROR]&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case FATAL:</span><br><span class="line">        pre = &quot;[FATAL]&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case DEBUG:</span><br><span class="line">        pre = &quot;[DEBUG]&quot;;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印时间和msg</span><br><span class="line">    std::cout &lt;&lt; pre + Timestamp::now().toString() &lt;&lt; &quot; : &quot; &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// int main() &#123;</span><br><span class="line">//     LOG_INFO(&quot;hello world, %d&quot;, 12);</span><br><span class="line">//     return 0;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>

<h2 id="对时间戳的疯涨"><a href="#对时间戳的疯涨" class="headerlink" title="对时间戳的疯涨"></a>对时间戳的疯涨</h2><p>Timestamp 类是对时间戳的封装，核心作用是方便地处理<br>“自 epoch 时间（1970 年 1 月 1 日 00:00:00 UTC）到当前时间的微秒数”，<br>并提供时间获取、格式化等常用操作，是日志系统、性能统计、事件时序管理等场景的基础组件。</p>
<p>代码实现</p>
<p><strong>Timestamp.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Timestamp</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Timestamp();</span><br><span class="line">    explicit Timestamp(int64_t microSecondsSinceEpoch);</span><br><span class="line">    static Timestamp now();</span><br><span class="line">    std::string toString() const; // const修饰，该函数只读</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int64_t microSecondsSinceEpoch_; // 微妙级</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Timestamp.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">Timestamp::Timestamp() : microSecondsSinceEpoch_(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Timestamp::Timestamp(int64_t microSecondsSinceEpoch)</span><br><span class="line">    : microSecondsSinceEpoch_(microSecondsSinceEpoch) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Timestamp Timestamp::now() &#123;</span><br><span class="line">    return Timestamp(time(NULL));</span><br><span class="line">&#125;</span><br><span class="line">std::string Timestamp::toString() const &#123;</span><br><span class="line">    char buf[128] = &#123;0&#125;;</span><br><span class="line">    tm *tm_time = localtime(&amp;microSecondsSinceEpoch_);</span><br><span class="line">    snprintf(buf, 128, &quot;%4d/%02d/%02d %02d:%02d:%02d&quot;,</span><br><span class="line">             tm_time-&gt;tm_year + 1900,</span><br><span class="line">             tm_time-&gt;tm_mon + 1,</span><br><span class="line">             tm_time-&gt;tm_mday,</span><br><span class="line">             tm_time-&gt;tm_hour,</span><br><span class="line">             tm_time-&gt;tm_min,</span><br><span class="line">             tm_time-&gt;tm_sec);</span><br><span class="line">    return buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// int main() &#123;</span><br><span class="line">//     std::cout &lt;&lt; Timestamp::now().toString() &lt;&lt; std::endl;</span><br><span class="line">//     return 0;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>


<h2 id="线程相关实现"><a href="#线程相关实现" class="headerlink" title="线程相关实现"></a>线程相关实现</h2><h3 id="CurrentThread"><a href="#CurrentThread" class="headerlink" title="CurrentThread"></a>CurrentThread</h3><p>Linux系统中，线程的ID(tid) 需要通过 syscall(SYS_gettid) 获取， 但是系统级的调用耗时较高<br>若多线程的场景下频繁的获取tid， 会影响性能。<br>CurrentThread 命名空间通过一下设计解决问题</p>
<hr>
<ol>
<li>保存tid缓存，线程本地存储（__thread） 每个线程一个</li>
<li>首次获取时调用系统调用，后续直接返回缓存值</li>
<li>编译器优化指令提升判断效率</li>
</ol>
<hr>
<p>代码实现<br><strong>CurrentThread.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">namespace CurrentThread &#123;</span><br><span class="line">    // __thread 用于声明线程本地存储变量</span><br><span class="line">    // 声明变量为外部定义（实际定义在 .cpp 文件中），避免头文件重复定义</span><br><span class="line">    extern __thread int t_cachedTid; // 保存tid缓存 因为系统调用非常耗时 拿到tid后将其保存</span><br><span class="line"></span><br><span class="line">    void cacheTid();</span><br><span class="line"></span><br><span class="line">    inline int tid() &#123; // 内联函数只在当前文件中起作用 </span><br><span class="line">        // __builtin_expect 是一种底层优化 此语句意思是如果还未获取tid 进入if 通过cacheTid()系统调用获取tid</span><br><span class="line">        if (__builtin_expect(t_cachedTid == 0, 0)) &#123;</span><br><span class="line">            cacheTid();</span><br><span class="line">        &#125;</span><br><span class="line">        return t_cachedTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CurrentThread.ccZ</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">namespace CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">    __thread int t_cachedTid = 0;</span><br><span class="line"></span><br><span class="line">    void cacheTid() &#123;</span><br><span class="line">        // 首次获取，使用系统调用</span><br><span class="line">        if (t_cachedTid == 0) &#123;</span><br><span class="line">            t_cachedTid = static_cast&lt;pid_t&gt;(::syscall(SYS_gettid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread-线程的封装"><a href="#Thread-线程的封装" class="headerlink" title="Thread 线程的封装"></a>Thread 线程的封装</h3><p>Thread 类是 C++ 中对线程操作的一个封装和增强。它的核心目标是让线程的创建、启动、管理和监控变得更加方便、安全和直观。<br>Thread 类，基于C++11 标准库的std::thread 进行封装，解决了std::thread 在实际项目中的几个痛点</p>
<hr>
<ol>
<li>线程状态管理，提供started_ 和 joined_ 成员变量解决了这个问题</li>
<li>线程标识，std::thread::id 是一个不透明的对象，<br>这个类，通过tid_ 成员变量存储了操作系统分配的线程id(tid)， 提供了tid() 方法</li>
<li>线程命名</li>
<li>禁止拷贝，线程是一个独立的执行单元</li>
</ol>
<hr>
<p>代码实现<br><strong>Thread.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable&quot;</span><br><span class="line"></span><br><span class="line">class Thread : noncopyable &#123;</span><br><span class="line">public:</span><br><span class="line">    using ThreadFunc = std::function&lt;void()&gt;;</span><br><span class="line">    explicit Thread(ThreadFunc, const std::string&amp; name = std::string());</span><br><span class="line">    ~Thread();</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line">    void join();</span><br><span class="line"></span><br><span class="line">    bool started() &#123;return started_; &#125;</span><br><span class="line">    pid_t tid() const &#123;return tid_; &#125;</span><br><span class="line">    const std::string&amp; name() const &#123;return name_; &#125;</span><br><span class="line">    static int numCreated() &#123;return numCreated_; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void setDefaultName();</span><br><span class="line"></span><br><span class="line">    // 线程状态</span><br><span class="line">    bool started_;</span><br><span class="line">    bool joined_;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt; thread_; </span><br><span class="line">    pid_t tid_;       // 在线程创建时再绑定</span><br><span class="line">    ThreadFunc func_; // 线程回调函数</span><br><span class="line">    std::string name_; </span><br><span class="line">    static std::atomic_int numCreated_; // 计数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Thread.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Thread.h&quot;</span><br><span class="line">#include &quot;CurrentThread.h&quot; </span><br><span class="line"></span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">std::atomic_int Thread::numCreated_(0);</span><br><span class="line"></span><br><span class="line">Thread::Thread(ThreadFunc func, const std::string name)</span><br><span class="line">    : started_(false)</span><br><span class="line">    , joined_(false)</span><br><span class="line">    , tid_(0)</span><br><span class="line">    , func_(std::move(func))</span><br><span class="line">    , name_(name) </span><br><span class="line">&#123;</span><br><span class="line">    setDefaultName();</span><br><span class="line">&#125;</span><br><span class="line">Thread::~Thread() &#123;</span><br><span class="line">    if (started_ &amp;&amp; !joined_) &#123;</span><br><span class="line">        thread_-&gt;detach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::start()                                                        // 一个Thread对象 记录的就是一个新线程的详细信息</span><br><span class="line">&#123;</span><br><span class="line">    started_ = true;</span><br><span class="line">    sem_t sem;</span><br><span class="line">    sem_init(&amp;sem, false, 0);                                               // false指的是 不设置进程间共享</span><br><span class="line">    // 开启线程</span><br><span class="line">    thread_ = std::shared_ptr&lt;std::thread&gt;(new std::thread([&amp;]() &#123;</span><br><span class="line">        tid_ = CurrentThread::tid();                                        // 获取线程的tid值</span><br><span class="line">        sem_post(&amp;sem);</span><br><span class="line">        func_();                                                            // 开启一个新线程 专门执行该线程函数</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    // 这里必须等待获取上面新创建的线程的tid值</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// C++ std::thread 中join()和detach()的区别：https://blog.nowcoder.net/n/8fcd9bb6e2e94d9596cf0a45c8e5858a</span><br><span class="line">void Thread::join()</span><br><span class="line">&#123;</span><br><span class="line">    joined_ = true;</span><br><span class="line">    thread_-&gt;join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Thread::setDefaultName() &#123;</span><br><span class="line">    int num = ++numCreated_;</span><br><span class="line">    if (name_.empty()) &#123;</span><br><span class="line">        char buf[32] = &#123;0&#125;;</span><br><span class="line">        snprintf(buf, sizeof buf, &quot;Thread%d&quot;, num);</span><br><span class="line">        name_ = buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阶段测试<br>编译指令：g++ test.cc .&#x2F;src&#x2F;CurrentThread.cc .&#x2F;src&#x2F;Thread.cc .&#x2F;src&#x2F;Timestamp.cc -o test -std&#x3D;c++17 -I .&#x2F;include</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Thread.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">void my_task() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; CurrentThread::tid() &lt;&lt; &quot; is running.&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; CurrentThread::tid() &lt;&lt; &quot; finished.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Thread t1(my_task, &quot;MyWorkerThread&quot;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Before start, Thread ID: &quot; &lt;&lt; t1.tid() &lt;&lt; std::endl; // 可能输出 0，也可能因为未同步而不确定，但在本实现中，start()会等待，所以这里没问题？不，这里在start()之前调用，tid_还是0。</span><br><span class="line">    </span><br><span class="line">    t1.start();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;After start, Thread ID: &quot; &lt;&lt; t1.tid() &lt;&lt; std::endl; // 一定能正确输出新线程的TID</span><br><span class="line">    </span><br><span class="line">    t1.join();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Thread joined.&quot; &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InetAddress-和-Socket"><a href="#InetAddress-和-Socket" class="headerlink" title="InetAddress 和 Socket"></a>InetAddress 和 Socket</h2><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><p>InetAddress 类是一个封装了 IPv4 socket 地址结构（sockaddr_in）的工具类<br>InetAddress 是网络编程中一个非常基础且实用的辅助类。<br>它将底层、繁琐的 C 语言 socket 地址操作封装成了优雅、安全的 C++ 方法，使得开发者能够更专注于业务逻辑，而不是底层的字节序转换和结构体操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">// 封装socket地址类型</span><br><span class="line">class InetAddress</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 构造函数 1：使用端口号和 IP 字符串创建对象</span><br><span class="line">    explicit InetAddress(uint16_t port = 0, std::string ip = &quot;127.0.0.1&quot;);</span><br><span class="line">    // 构造函数 2：使用已有的 sockaddr_in 结构体创建对象</span><br><span class="line">    explicit InetAddress(const sockaddr_in &amp;addr)</span><br><span class="line">        : addr_(addr)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::string toIp() const;</span><br><span class="line">    std::string toIpPort() const;</span><br><span class="line">    uint16_t toPort() const;</span><br><span class="line"></span><br><span class="line">    const sockaddr_in *getSockAddr() const &#123; return &amp;addr_; &#125;</span><br><span class="line">    void setSockAddr(const sockaddr_in &amp;addr) &#123; addr_ = addr; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    sockaddr_in addr_; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket 类是对操作系统底层 socket 文件描述符（fd）的封装，遵循 noncopyable 语义（不可拷贝），核心作用是隐藏 socket 系统调用的底层细节，提供安全、简洁的 C++ 接口，用于创建、绑定、监听、接受连接等 TCP 通信核心操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line"></span><br><span class="line">class InetAddress;</span><br><span class="line"></span><br><span class="line">// 封装socket fd</span><br><span class="line">class Socket : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Socket(int sockfd)</span><br><span class="line">        : sockfd_(sockfd)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Socket();</span><br><span class="line"></span><br><span class="line">    int fd() const &#123; return sockfd_; &#125;</span><br><span class="line">    void bindAddress(const InetAddress &amp;localaddr);</span><br><span class="line">    void listen();</span><br><span class="line">    int accept(InetAddress *peeraddr);</span><br><span class="line"></span><br><span class="line">    void shutdownWrite();</span><br><span class="line"></span><br><span class="line">    void setTcpNoDelay(bool on);</span><br><span class="line">    void setReuseAddr(bool on);</span><br><span class="line">    void setReusePort(bool on);</span><br><span class="line">    void setKeepAlive(bool on);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    const int sockfd_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="项目重点类实现细节"><a href="#项目重点类实现细节" class="headerlink" title="项目重点类实现细节"></a>项目重点类实现细节</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>这个 Channel 类是 Reactor 事件驱动模型中的核心组件之一，<br>是 <strong>“事件分发器”或“I&#x2F;O 对象代理”的角色。它的核心职责是封装一个文件描述符（fd）及其感兴趣的I&#x2F;O 事件（如读、写），并在事件就绪时，将事件分发给事先注册好的回调函数</strong></p>
<p>代码实现细节与解释<br><strong>Channel.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line">#include &quot;Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">class EventLoop; </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 理清楚 EventLoop、Channel、Poller之间的关系  Reactor模型上对应多路事件分发器</span><br><span class="line"> * Channel理解为通道 封装了sockfd和其感兴趣的event 如EPOLLIN、EPOLLOUT事件 还绑定了poller返回的具体事件</span><br><span class="line"> **/</span><br><span class="line">class Channel : noncopyable  // 继承noncopyable，禁止拷贝Channel对象</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 定义回调函数类型：</span><br><span class="line">    // EventCallback 是无参无返回的函数对象，用于处理写、关闭、错误事件</span><br><span class="line">    using EventCallback = std::function&lt;void()&gt;; </span><br><span class="line">    // ReadEventCallback 是带Timestamp参数的函数对象，用于处理读事件（时间戳记录事件发生时间）</span><br><span class="line">    using ReadEventCallback = std::function&lt;void(Timestamp)&gt;;</span><br><span class="line"></span><br><span class="line">    // 构造函数：初始化所属的EventLoop、文件描述符fd</span><br><span class="line">    Channel(EventLoop *loop, int fd);</span><br><span class="line">    ~Channel();  // 析构函数</span><br><span class="line"></span><br><span class="line">    // 处理Poller通知的事件，在EventLoop::loop()中被调用</span><br><span class="line">    void handleEvent(Timestamp receiveTime);</span><br><span class="line"></span><br><span class="line">    // 设置各种事件的回调函数，使用std::move转移所有权，避免拷贝开销</span><br><span class="line">    void setReadCallback(ReadEventCallback cb) &#123; readCallback_ = std::move(cb); &#125;</span><br><span class="line">    void setWriteCallback(EventCallback cb) &#123; writeCallback_ = std::move(cb); &#125;</span><br><span class="line">    void setCloseCallback(EventCallback cb) &#123; closeCallback_ = std::move(cb); &#125;</span><br><span class="line">    void setErrorCallback(EventCallback cb) &#123; errorCallback_ = std::move(cb); &#125;</span><br><span class="line"></span><br><span class="line">    // 绑定一个对象的shared_ptr，防止回调执行时对象被销毁（通过weak_ptr实现安全访问）</span><br><span class="line">    void tie(const std::shared_ptr&lt;void&gt; &amp;);</span><br><span class="line"></span><br><span class="line">    // 以下是获取成员变量的内联函数：</span><br><span class="line">    int fd() const &#123; return fd_; &#125;         // 获取封装的文件描述符</span><br><span class="line">    int events() const &#123; return events_; &#125; // 获取感兴趣的事件集合</span><br><span class="line">    void set_revents(int revt) &#123; revents_ = revt; &#125; // 设置实际发生的事件（由Poller调用）</span><br><span class="line"></span><br><span class="line">    // 以下方法用于修改感兴趣的事件，并通知EventLoop更新Poller的监控</span><br><span class="line">    void enableReading() &#123; events_ |= kReadEvent; update(); &#125;  // 启用读事件</span><br><span class="line">    void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125; // 禁用读事件</span><br><span class="line">    void enableWriting() &#123; events_ |= kWriteEvent; update(); &#125;  // 启用写事件</span><br><span class="line">    void disableWriting() &#123; events_ &amp;= ~kWriteEvent; update(); &#125; // 禁用写事件</span><br><span class="line">    void disableAll() &#123; events_ = kNoneEvent; update(); &#125;       // 禁用所有事件</span><br><span class="line"></span><br><span class="line">    // 判断当前感兴趣的事件状态</span><br><span class="line">    bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;</span><br><span class="line">    bool isWriting() const &#123; return events_ &amp; kWriteEvent; &#125;</span><br><span class="line">    bool isReading() const &#123; return events_ &amp; kReadEvent; &#125;</span><br><span class="line"></span><br><span class="line">    int index() &#123; return index_; &#125;         // 获取在Poller中的索引（用于Poller内部管理）</span><br><span class="line">    void set_index(int idx) &#123; index_ = idx; &#125; // 设置在Poller中的索引</span><br><span class="line"></span><br><span class="line">    EventLoop *ownerLoop() &#123; return loop_; &#125; // 获取所属的EventLoop</span><br><span class="line">    void remove();  // 从EventLoop和Poller中移除当前Channel</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    void update();  // 通知EventLoop更新Poller对当前Channel的监控</span><br><span class="line">    void handleEventWithGuard(Timestamp receiveTime); // 带对象生命周期保护的事件处理</span><br><span class="line"></span><br><span class="line">    // 静态常量，定义事件类型（位掩码）</span><br><span class="line">    static const int kNoneEvent;   // 无事件</span><br><span class="line">    static const int kReadEvent;   // 读事件（EPOLLIN | EPOLLPRI）</span><br><span class="line">    static const int kWriteEvent;  // 写事件（EPOLLOUT）</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_;  // 所属的EventLoop，Channel的所有操作都在该loop的线程中执行</span><br><span class="line">    const int fd_;     // 封装的文件描述符，const表示fd一旦初始化不可修改</span><br><span class="line">    int events_;       // 感兴趣的事件（由用户设置，如读、写）</span><br><span class="line">    int revents_;      // 实际发生的事件（由Poller填充）</span><br><span class="line">    int index_;        // 在Poller中的索引，用于Poller高效管理事件</span><br><span class="line"></span><br><span class="line">    std::weak_ptr&lt;void&gt; tie_;  // 临时保护生命周期</span><br><span class="line">    bool tied_;                // 标记是否已绑定对象</span><br><span class="line"></span><br><span class="line">    // 事件发生时的回调函数</span><br><span class="line">    ReadEventCallback readCallback_;   // 读事件回调</span><br><span class="line">    EventCallback writeCallback_;      // 写事件回调</span><br><span class="line">    EventCallback closeCallback_;      // 关闭事件回调</span><br><span class="line">    EventCallback errorCallback_;      // 错误事件回调</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Channel.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  // 包含epoll相关系统调用宏（如EPOLLIN、EPOLLOUT、EPOLLHUP等）</span><br><span class="line"></span><br><span class="line">#include &quot;Channel.h&quot;    // 包含Channel类的声明</span><br><span class="line">#include &quot;EventLoop.h&quot;  // 包含EventLoop类的声明（用于调用updateChannel/removeChannel）</span><br><span class="line">#include &quot;Logger.h&quot;     // 日志工具类（用于打印事件处理日志）</span><br><span class="line"></span><br><span class="line">// 初始化Channel类的静态常量（事件类型定义）</span><br><span class="line">const int Channel::kNoneEvent = 0;                          // 空事件（无感兴趣的事件）</span><br><span class="line">const int Channel::kReadEvent = EPOLLIN | EPOLLPRI;         // 读事件：EPOLLIN（普通数据可读）+ EPOLLPRI（紧急数据可读）</span><br><span class="line">const int Channel::kWriteEvent = EPOLLOUT;                  // 写事件：EPOLLOUT（数据可写）</span><br><span class="line"></span><br><span class="line">// Channel构造函数：初始化成员变量</span><br><span class="line">// 参数：loop_（所属的EventLoop）、fd_（封装的文件描述符）</span><br><span class="line">Channel::Channel(EventLoop *loop, int fd)</span><br><span class="line">    : loop_(loop)    // 绑定当前Channel所属的EventLoop（一个Channel只能属于一个EventLoop）</span><br><span class="line">    , fd_(fd)        // 赋值封装的fd（const修饰，一旦初始化不可修改）</span><br><span class="line">    , events_(0)     // 初始化为空事件（默认不关注任何事件）</span><br><span class="line">    , revents_(0)    // 初始化为空（实际发生的事件由Poller填充）</span><br><span class="line">    , index_(-1)     // 初始化为-1（表示该Channel尚未注册到Poller中，用于Poller内部管理）</span><br><span class="line">    , tied_(false)   // 初始化为false（表示未绑定任何对象的生命周期）</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Channel::~Channel()</span><br><span class="line">&#123;</span><br><span class="line">    // 析构函数为空：Channel不直接管理fd的生命周期（fd由TcpConnection等所有者管理）</span><br><span class="line">    // 仅当Channel被remove后，才会从Poller中移除fd的监控</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 绑定一个对象的shared_ptr，通过weak_ptr保护对象生命周期</span><br><span class="line">// 参数：obj（要绑定的对象的shared_ptr，通常是TcpConnection实例）</span><br><span class="line">void Channel::tie(const std::shared_ptr&lt;void&gt; &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    tie_ = obj;      // 将shared_ptr赋值给weak_ptr（weak_ptr不增加引用计数，不影响对象销毁）</span><br><span class="line">    tied_ = true;    // 标记已绑定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通知EventLoop更新当前Channel在Poller中的监控状态（add/mod操作）</span><br><span class="line">void Channel::update()</span><br><span class="line">&#123;</span><br><span class="line">    // 调用所属EventLoop的updateChannel方法，间接委托Poller处理fd的事件注册/修改</span><br><span class="line">    loop_-&gt;updateChannel(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通知EventLoop从Poller中移除当前Channel（del操作）</span><br><span class="line">void Channel::remove()</span><br><span class="line">&#123;</span><br><span class="line">    // 调用所属EventLoop的removeChannel方法，间接委托Poller删除fd的监控</span><br><span class="line">    loop_-&gt;removeChannel(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 核心方法：处理Poller通知的事件（在EventLoop::loop()中被调用）</span><br><span class="line">// 参数：receiveTime（事件发生的时间戳，由Poller传递）</span><br><span class="line">void Channel::handleEvent(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">    if (tied_)  // 如果已绑定对象（如TcpConnection），需要先检查对象是否存活</span><br><span class="line">    &#123;</span><br><span class="line">        // 尝试将weak_ptr提升为shared_ptr：成功则对象存活，失败则对象已销毁</span><br><span class="line">        std::shared_ptr&lt;void&gt; guard = tie_.lock();</span><br><span class="line">        if (guard)  // 对象存活，执行带保护的事件处理</span><br><span class="line">        &#123;</span><br><span class="line">            handleEventWithGuard(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">        // 若提升失败（对象已销毁），则不执行任何回调（避免访问已销毁对象）</span><br><span class="line">    &#125;</span><br><span class="line">    else  // 未绑定对象，直接处理事件</span><br><span class="line">    &#123;</span><br><span class="line">        handleEventWithGuard(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 带对象生命周期保护的事件处理逻辑（实际执行回调的核心）</span><br><span class="line">void Channel::handleEventWithGuard(Timestamp receiveTime)</span><br><span class="line">&#123;</span><br><span class="line">    // 打印日志：输出当前触发的事件类型（revents_是Poller填充的实际发生的事件）</span><br><span class="line">    LOG_INFO(&quot;channel handleEvent revents:%d\n&quot;, revents_);</span><br><span class="line"></span><br><span class="line">    // 1. 处理关闭事件（EPOLLHUP）：连接被对端关闭或挂起</span><br><span class="line">    // 条件：触发EPOLLHUP且未触发EPOLLIN（避免重复处理）</span><br><span class="line">    // 场景：如客户端调用close()关闭连接，服务端socket会触发EPOLLHUP</span><br><span class="line">    if ((revents_ &amp; EPOLLHUP) &amp;&amp; !(revents_ &amp; EPOLLIN))</span><br><span class="line">    &#123;</span><br><span class="line">        if (closeCallback_)  // 若注册了关闭回调，执行回调</span><br><span class="line">        &#123;</span><br><span class="line">            closeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 处理错误事件（EPOLLERR）：fd发生错误（如连接重置、fd无效）</span><br><span class="line">    if (revents_ &amp; EPOLLERR)</span><br><span class="line">    &#123;</span><br><span class="line">        if (errorCallback_)  // 若注册了错误回调，执行回调</span><br><span class="line">        &#123;</span><br><span class="line">            errorCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 处理读事件（EPOLLIN：普通数据可读 / EPOLLPRI：紧急数据可读）</span><br><span class="line">    if (revents_ &amp; (EPOLLIN | EPOLLPRI))</span><br><span class="line">    &#123;</span><br><span class="line">        if (readCallback_)  // 若注册了读回调，传入事件发生时间戳并执行</span><br><span class="line">        &#123;</span><br><span class="line">            readCallback_(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. 处理写事件（EPOLLOUT：fd可写，如发送缓冲区有空闲空间）</span><br><span class="line">    if (revents_ &amp; EPOLLOUT)</span><br><span class="line">    &#123;</span><br><span class="line">        if (writeCallback_)  // 若注册了写回调，执行回调</span><br><span class="line">        &#123;</span><br><span class="line">            writeCallback_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="这份实现完整体现了-Channel-类的核心职责：封装-fd-和事件（感兴趣事件-events-、实际发生事件-revents-）；提供回调注册接口，在事件发生时按优先级分发回调；通过-tie-机制保护对象生命周期，避免野指针访问；委托-EventLoop-与-Poller-交互，解耦底层-I-O-多路复用实现。"><a href="#这份实现完整体现了-Channel-类的核心职责：封装-fd-和事件（感兴趣事件-events-、实际发生事件-revents-）；提供回调注册接口，在事件发生时按优先级分发回调；通过-tie-机制保护对象生命周期，避免野指针访问；委托-EventLoop-与-Poller-交互，解耦底层-I-O-多路复用实现。" class="headerlink" title="这份实现完整体现了 Channel 类的核心职责：封装 fd 和事件（感兴趣事件 events_、实际发生事件 revents_）；提供回调注册接口，在事件发生时按优先级分发回调；通过 tie 机制保护对象生命周期，避免野指针访问；委托 EventLoop 与 Poller 交互，解耦底层 I&#x2F;O 多路复用实现。"></a>这份实现完整体现了 Channel 类的核心职责：<br>封装 fd 和事件（感兴趣事件 events_、实际发生事件 revents_）；<br>提供回调注册接口，在事件发生时按优先级分发回调；<br>通过 tie 机制保护对象生命周期，避免野指针访问；<br>委托 EventLoop 与 Poller 交互，解耦底层 I&#x2F;O 多路复用实现。</h2><h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>Poller 是 C++ 高性能网络编程（Reactor 模型）中的I&#x2F;O 多路复用核心组件，<br>封装了 epoll&#x2F;poll&#x2F;select 等底层系统调用，核心职责是批量监听多个文件描述符（fd）的感兴趣事件，<br>当事件就绪时通知 EventLoop，是实现 “高并发” 的关键（避免为每个 fd 创建线程）。</p>
<p>该功能核心目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高效管理大量 fd（支持成千上万个并发连接）。</span><br><span class="line">阻塞等待就绪事件（减少 CPU 空轮询）。</span><br><span class="line">将就绪事件快速通知 EventLoop，由 EventLoop 分发给对应 Channel 执行回调。</span><br></pre></td></tr></table></figure>

<p>Poller 通常是抽象基类，具体实现由 EpollPoller（封装 epoll）、PollPoller（封装 poll）等派生类完成。<br>本项目只实现EpollPoller功能</p>
<p><strong>Poller.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line">#include &quot;Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">// muduo库中多路事件分发器的核心IO复用模块</span><br><span class="line">class Poller</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using ChannelList = std::vector&lt;Channel *&gt;;</span><br><span class="line"></span><br><span class="line">    Poller(EventLoop *loop);</span><br><span class="line">    virtual ~Poller() = default;</span><br><span class="line"></span><br><span class="line">    // 给所有IO复用保留统一的接口</span><br><span class="line">    virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels) = 0;</span><br><span class="line">    virtual void updateChannel(Channel *channel) = 0;</span><br><span class="line">    virtual void removeChannel(Channel *channel) = 0;</span><br><span class="line"></span><br><span class="line">    // 判断参数channel是否在当前的Poller当中</span><br><span class="line">    bool hasChannel(Channel *channel) const;</span><br><span class="line"></span><br><span class="line">    // EventLoop可以通过该接口获取默认的IO复用的具体实现</span><br><span class="line">    static Poller *newDefaultPoller(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    // map的key:sockfd value:sockfd所属的channel通道类型</span><br><span class="line">    using ChannelMap = std::unordered_map&lt;int, Channel *&gt;;</span><br><span class="line">    ChannelMap channels_;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    EventLoop *ownerLoop_; // 定义Poller所属的事件循环EventLoop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Poller.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Poller.h&quot;</span><br><span class="line">#include &quot;Channel.h&quot;</span><br><span class="line"></span><br><span class="line">Poller::Poller(EventLoop *loop)</span><br><span class="line">    : ownerLoop_(loop)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Poller::hasChannel(Channel *channel) const</span><br><span class="line">&#123;</span><br><span class="line">    auto it = channels_.find(channel-&gt;fd());</span><br><span class="line">    return it != channels_.end() &amp;&amp; it-&gt;second == channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充DefaultPoller.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这段代码是一个非常优雅的设计，它通过工厂模式封装了 Poller 对象的创建过程。其核心特点和意图如下：</span><br><span class="line">封装实现细节：EventLoop 无需关心 Poller 的具体实现。</span><br><span class="line">默认高性能：优先选择 epoll 作为 I/O 多路复用的后端，以获得最佳性能。</span><br><span class="line">灵活性与可配置性：通过环境变量 MUDUO_USE_POLL，允许用户在必要时切换到 poll 实现，增强了代码的灵活性和可测试性。</span><br><span class="line">可扩展性：增加新的 Poller 实现非常方便，符合 “开放 - 封闭原则”。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;Poller.h&quot;</span><br><span class="line">#include &quot;EPollPoller.h&quot;</span><br><span class="line"></span><br><span class="line">//由于只实现了 EPollPoller，所以这样实现</span><br><span class="line">Poller *Poller::newDefaultPoller(EventLoop *loop)</span><br><span class="line">&#123;</span><br><span class="line">    if (::getenv(&quot;MUDUO_USE_POLL&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        return nullptr; // 生成poll的实例</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return new EPollPoller(loop); // 生成epoll的实例</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EPollPoller-实现"><a href="#EPollPoller-实现" class="headerlink" title="EPollPoller 实现"></a>EPollPoller 实现</h2><p>EPollPoller 是 muduo 等 Reactor 模型框架中的核心组件，封装了 Linux 下的 epoll I&#x2F;O 多路复用机制，<br>用于高效监听大量文件描述符（fd）的读写事件，是实现高并发网络编程的关键</p>
<p>Timestamp poll(int timeoutMs, ChannelList* activeChannels)<br>这个函数是Poller的核心，将事件监听器听到该fd发生的事件写进Channel中的revents成员变量中，<br>把这个Channel 装进activeChannels中，这样调用完之后能拿到事件监听器的监听结果</p>
<p><strong>EPollPoller.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;Poller.h&quot;</span><br><span class="line">#include &quot;Timestamp.h&quot;</span><br><span class="line"></span><br><span class="line">class Channel;</span><br><span class="line"></span><br><span class="line">// EpollPoller 是 Poller 的子类，封装了 epoll 的功能实现</span><br><span class="line">class EPollPoller : public Poller &#123;</span><br><span class="line">public:</span><br><span class="line">    // 构造函数：传入所属的 EventLoop</span><br><span class="line">    EPollPoller(EventLoop* loop);</span><br><span class="line">    // 析构函数：override 确保正确重写基类析构</span><br><span class="line">    ~EPollPoller() override;</span><br><span class="line"></span><br><span class="line">    // 重写基类的抽象方法，实现 epoll_wait 逻辑，返回活跃事件的时间戳</span><br><span class="line">    Timestamp poll(int timeoutMs, ChannelList* activeChannels) override;</span><br><span class="line">    // 重写基类方法，更新 Channel 在 epoll 中的事件监控状态</span><br><span class="line">    void updateChannel(Channel *channel) override;</span><br><span class="line">    // 重写基类方法，将 Channel 从 epoll 监控中移除</span><br><span class="line">    void removeChannel(Channel *channel) override;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 定义 epoll_event 向量的初始容量，避免频繁扩容</span><br><span class="line">    static const int kInitEventListSize = 16;</span><br><span class="line"></span><br><span class="line">    // 核心辅助方法：将 epoll_wait 返回的就绪事件填充到 activeChannels（传出参数）</span><br><span class="line">    void fillActiveChannels(int numEvents, ChannelList *activeChannels) const;</span><br><span class="line">    // 底层辅助方法：调用 epoll_ctl 执行 ADD/MOD/DEL 操作，更新 epoll 内部状态</span><br><span class="line">    void update(int operation, Channel *channel);</span><br><span class="line"></span><br><span class="line">    // 类型别名：简化 epoll_event 向量的写法，提高代码可读性</span><br><span class="line">    using EventList = std::vector&lt;epoll_event&gt;;</span><br><span class="line"></span><br><span class="line">    int epollfd_; // epoll 实例的文件描述符（由 epoll_create 创建）</span><br><span class="line">    EventList events_; // 存储 epoll_wait 返回的就绪事件列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体功能实现<br><strong>EPollPoller.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;EPollPoller.h&quot;</span><br><span class="line">#include &quot;Logger.h&quot;</span><br><span class="line">#include &quot;Channel.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">const int kNew = -1;    // 某个channel还没添加至Poller          // channel的成员index_初始化为-1</span><br><span class="line">const int kAdded = 1;   // 某个channel已经添加至Poller</span><br><span class="line">const int kDeleted = 2; // 某个channel已经从Poller删除</span><br><span class="line"></span><br><span class="line">EPollPoller::EPollPoller(EventLoop *loop) </span><br><span class="line">    :Poller(loop)</span><br><span class="line">    ,epollfd_(::epoll_create(EPOLL_CLOEXEC))</span><br><span class="line">    ,events_(kInitEventListSize)  // std::vector&lt;epoll_event&gt;(16)</span><br><span class="line">&#123;</span><br><span class="line">    if (epollfd_ &lt; 0) &#123;</span><br><span class="line">        LOG_FATAL(&quot;epoll_create error:%d\n&quot;, errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EPollPoller::~EPollPoller() &#123;</span><br><span class="line">    ::close(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监听</span><br><span class="line">Timestamp EPollPoller::poll(int timeoutMs, ChannelList *activeChannels) &#123;</span><br><span class="line">    // 由于频繁调用poll 实际上应该用LOG_DEBUG输出日志更为合理 当遇到并发场景 关闭DEBUG日志提升效率</span><br><span class="line">    LOG_INFO(&quot;func=%s =&gt; fd total count:%lu\n&quot;, __FUNCTION__, channels_.size());</span><br><span class="line"></span><br><span class="line">    int numEvents = ::epoll_wait(epollfd_, &amp;*events_.begin(), static_cast&lt;int&gt;(events_.size()), timeoutMs);</span><br><span class="line">    int saveErrno = errno;</span><br><span class="line">    // 返回事件发生的精准时间</span><br><span class="line">    Timestamp now(Timestamp::now());</span><br><span class="line"></span><br><span class="line">    if (numEvents &gt; 0) &#123;</span><br><span class="line">        LOG_INFO(&quot;%d events happend\n&quot;, numEvents); // LOG_DEBUG最合理</span><br><span class="line">        fillActiveChannels(numEvents, activeChannels);</span><br><span class="line">        if (numEvents == events_.size()) &#123;</span><br><span class="line">            // 扩容操作</span><br><span class="line">            events_.resize(events_.size() * 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (numEvents == 0) &#123;</span><br><span class="line">        LOG_DEBUG(&quot;%s timeout!\n&quot;, __FUNCTION__);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (saveErrno != EINTR) &#123;</span><br><span class="line">            errno = saveErrno;</span><br><span class="line">            LOG_ERROR(&quot;EPollPoller::poll() error!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return now;</span><br><span class="line">&#125;</span><br><span class="line">// 重写基类方法，更新 Channel 在 epoll 中的事件监控状态</span><br><span class="line">void EPollPoller::updateChannel(Channel *channel) &#123;</span><br><span class="line">    const int index = channel-&gt;index();</span><br><span class="line">    LOG_INFO(&quot;func=%s =&gt; fd=%d events=%d index=%d\n&quot;, __FUNCTION__, channel-&gt;fd(), channel-&gt;events(), index);</span><br><span class="line"></span><br><span class="line">    if (index == kNew || index == kDeleted) &#123;</span><br><span class="line">        if (index == kNew) &#123;</span><br><span class="line">            int fd = channel-&gt;fd();</span><br><span class="line">            channels_[fd] = channel;</span><br><span class="line">        &#125; else &#123; // index == kDeleted</span><br><span class="line">        &#125; </span><br><span class="line">        channel-&gt;set_index(kAdded); // 将状态设置为“已添加”</span><br><span class="line">        update(EPOLL_CTL_ADD, channel); // 调用底层update函数，执行epoll_ctl ADD操作</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // channel已经在Poller中注册过了</span><br><span class="line">        // 断言：确保在channels_映射表中能找到这个fd，这是一个一致性检查</span><br><span class="line">        assert(channels_.find(fd) != channels_.end());</span><br><span class="line">        assert(channels_[fd] == channel);</span><br><span class="line">        int fd = channel-&gt;fd();</span><br><span class="line">        if (channel-&gt;isNoneEvent()) &#123;</span><br><span class="line">            update(EPOLL_CTL_DEL, channel);</span><br><span class="line">            channel-&gt;set_index(kDeleted);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            update(EPOLL_CTL_MOD, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 重写基类方法，将 Channel 从 epoll 监控中移除</span><br><span class="line">void EPollPoller::removeChannel(Channel *channel) &#123;</span><br><span class="line">    int fd = channel-&gt;fd();</span><br><span class="line">    channels_.erase(fd);</span><br><span class="line"></span><br><span class="line">    LOG_INFO(&quot;func=%s =&gt; fd=%d\n&quot;, __FUNCTION__, fd);</span><br><span class="line"></span><br><span class="line">    int index = channel-&gt;index();</span><br><span class="line">    if (index == kAdded)</span><br><span class="line">    &#123;</span><br><span class="line">        update(EPOLL_CTL_DEL, channel);</span><br><span class="line">    &#125;</span><br><span class="line">    channel-&gt;set_index(kNew);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 核心辅助方法：将 epoll_wait 返回的就绪事件填充到 activeChannels（传出参数）</span><br><span class="line">// 填写活跃的连接</span><br><span class="line">void EPollPoller::fillActiveChannels(int numEvents, ChannelList *activeChannels) const</span><br><span class="line">&#123;</span><br><span class="line">    // 遍历所有epoll返回的就绪事件</span><br><span class="line">    for (int i = 0; i &lt; numEvents; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        // 1. 从epoll_event中获取Channel指针</span><br><span class="line">        // events_[i] 是一个 struct epoll_event</span><br><span class="line">        // events_[i].data.ptr 是我们在调用epoll_ctl时，通过 event.data.ptr 字段存入的 Channel*</span><br><span class="line">        // 这里是将其强制转换回 Channel* 类型</span><br><span class="line">        Channel *channel = static_cast&lt;Channel *&gt;(events_[i].data.ptr);</span><br><span class="line">        </span><br><span class="line">        // 2. 将epoll返回的具体事件类型设置到Channel对象中</span><br><span class="line">        // events_[i].events 是一个整数，代表了发生的事件类型（如 EPOLLIN, EPOLLOUT, EPOLLERR）</span><br><span class="line">        // channel-&gt;set_revents(...) 将这个事件类型存入Channel的 revents_ 成员变量</span><br><span class="line">        // 这个 revents_ 就是Channel的 handleEvent() 方法判断应该执行哪个回调的依据</span><br><span class="line">        channel-&gt;set_revents(events_[i].events);</span><br><span class="line">        </span><br><span class="line">        // 3. 将就绪的Channel添加到输出列表中</span><br><span class="line">        // activeChannels 是一个由 EventLoop 传入的空列表</span><br><span class="line">        // push_back(channel) 将当前这个发生了事件的Channel指针添加到列表末尾</span><br><span class="line">        activeChannels-&gt;push_back(channel); // EventLoop就拿到了它的Poller给它返回的所有发生事件的channel列表了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 底层辅助方法：调用 epoll_ctl 执行 ADD/MOD/DEL 操作，更新 epoll 内部状态</span><br><span class="line">void EPollPoller::update(int operation, Channel *channel) &#123;</span><br><span class="line">    epoll_event event; </span><br><span class="line">    ::memset(&amp;event, 0, sizeof(event));</span><br><span class="line"></span><br><span class="line">    int fd = channel-&gt;fd();</span><br><span class="line"></span><br><span class="line">    event.events = channel-&gt;events();</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    //这是最关键的一步！将 Channel 对象的指针存入 event.data.ptr 字段。</span><br><span class="line">    // 当这个 fd 上有事件发生时，epoll_wait 会返回这个 event 结构体，</span><br><span class="line">    // 我们就可以通过 event.data.ptr 快速地找到对应的 Channel 对象，</span><br><span class="line">    // 而无需再通过 fd 去 channels_ 映射表中查找。这是 Channel 和 epoll_event 之间的直接桥梁。</span><br><span class="line">    event.data.ptr = channel;</span><br><span class="line"></span><br><span class="line">    if (::epoll_ctl(epollfd_, operation, fd, &amp;event) &lt; 0) &#123;</span><br><span class="line">        if (operation == EPOLL_CTL_DEL) &#123;</span><br><span class="line">            LOG_ERROR(&quot;epoll_ctl del error:%d\n&quot;, errno);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            LOG_FATAL(&quot;epoll_ctl add/mod error:%d\n&quot;, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>作为一个网络服务器，需要有持续监听，持续获取监听结果，持续处理监听结果对应事件的能力<br>也就是我们需要循环的去 <strong>调用Poller::poll方法获取实际发生事件的Channel集合</strong> 然后<br>调用这些Channel里面保管的不同类型事件的处理函数<br>EventLoop就是负责实现 “循环” ，负责驱动 “循环” 的重要模块<br>这个类整合封装了二者并向上提供了更方便的接口</p>
<p><strong>EventLoop.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"> </span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line">#include &quot;Timestamp.h&quot;</span><br><span class="line">#include &quot;CurrentThread.h&quot;</span><br><span class="line"></span><br><span class="line">// 前置声明，避免循环依赖</span><br><span class="line">class Channel;</span><br><span class="line">class Poller;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 事件循环类 (Reactor 模式的核心)</span><br><span class="line"> * </span><br><span class="line"> * 一个 EventLoop 实例代表一个独立的事件循环线程。它负责：</span><br><span class="line"> * 1. 通过 Poller (I/O 多路复用器) 等待 I/O 事件（如 socket 可读、可写）。</span><br><span class="line"> * 2. 当事件发生时，调用相应 Channel 的回调函数进行处理。</span><br><span class="line"> * 3. 执行用户通过 runInLoop/queueInLoop 投递的任务（Functor）。</span><br><span class="line"> * </span><br><span class="line"> * 核心特性：</span><br><span class="line"> * - 每个 EventLoop 对象绑定一个线程，通过 threadId_ 标识。</span><br><span class="line"> * - 线程安全的任务队列 (pendingFunctors_)，允许跨线程投递任务。</span><br><span class="line"> * - 使用 wakeupFd_ 实现高效的跨线程唤醒。</span><br><span class="line"> * </span><br><span class="line"> * 注意：</span><br><span class="line"> * - 一个线程只能拥有一个 EventLoop 对象。</span><br><span class="line"> * - EventLoop 的生命周期通常由其所属的线程（如 TcpServer 的主循环线程）管理。</span><br><span class="line"> */</span><br><span class="line">class EventLoop : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 定义任务回调类型</span><br><span class="line">    using Functor = std::function&lt;void()&gt;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 构造函数</span><br><span class="line">     * </span><br><span class="line">     * 在构造时，会：</span><br><span class="line">     * 1. 记录当前线程 ID (threadId_)。</span><br><span class="line">     * 2. 创建 Poller 对象 (epoll/poll 的封装)。</span><br><span class="line">     * 3. 创建 wakeupFd_ (通过 eventfd) 并封装成 wakeupChannel_。</span><br><span class="line">     * 4. 将 wakeupChannel_ 的读事件回调设置为 handleRead，用于唤醒事件循环。</span><br><span class="line">     */</span><br><span class="line">    EventLoop();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 析构函数</span><br><span class="line">     * </span><br><span class="line">     * 确保在析构时事件循环已经停止 (quit_ 为 true)。</span><br><span class="line">     */</span><br><span class="line">    ~EventLoop();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 启动事件循环的主循环</span><br><span class="line">     * </span><br><span class="line">     * 这是 EventLoop 的核心方法，调用后会进入一个无限循环，直到 quit() 被调用。</span><br><span class="line">     * 循环逻辑：</span><br><span class="line">     * 1. 调用 Poller::poll() 阻塞等待事件，超时时间由 kPollTimeMs 指定。</span><br><span class="line">     * 2. poll() 返回后，获取就绪的 Channel 列表 (activeChannels_)。</span><br><span class="line">     * 3. 遍历 activeChannels_，调用每个 Channel 的 handleEvent() 方法处理事件。</span><br><span class="line">     * 4. 执行 doPendingFunctors()，处理在此期间被投递到队列中的任务。</span><br><span class="line">     * </span><br><span class="line">     * 注意：此方法会阻塞调用线程，通常在一个线程的主函数中调用。</span><br><span class="line">     */</span><br><span class="line">    void loop();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 安全地退出事件循环</span><br><span class="line">     * </span><br><span class="line">     * 设置 quit_ 标志为 true。如果调用此方法的线程不是 EventLoop 所属的线程，</span><br><span class="line">     * 必须唤醒事件循环线程，使其从 poll() 的阻塞中返回，以便检查 quit_ 标志并退出。</span><br><span class="line">     */</span><br><span class="line">    void quit();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 获取最近一次 poll() 返回的时间戳</span><br><span class="line">     * @return Timestamp 最近一次 I/O 事件就绪的时间</span><br><span class="line">     */</span><br><span class="line">    Timestamp pollReturnTime() const;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 在 EventLoop 所属的线程中执行一个任务</span><br><span class="line">     * </span><br><span class="line">     * 如果调用此方法的线程就是 EventLoop 所属的线程，则立即执行任务 cb。</span><br><span class="line">     * 否则，将任务 cb 投递到任务队列 pendingFunctors_ 中，并唤醒事件循环线程以尽快执行。</span><br><span class="line">     * </span><br><span class="line">     * @param cb 要执行的任务回调</span><br><span class="line">     */</span><br><span class="line">    void runInLoop(Functor cb);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 将一个任务投递到 EventLoop 的任务队列中，待后续执行</span><br><span class="line">     * </span><br><span class="line">     * 此方法是线程安全的。它会将任务 cb 加入 pendingFunctors_，</span><br><span class="line">     * 并根据情况决定是否需要唤醒事件循环线程。</span><br><span class="line">     * 唤醒的条件是：</span><br><span class="line">     * 1. 调用线程不是 EventLoop 所属线程。</span><br><span class="line">     * 2. 事件循环正在执行任务队列 (callingPendingFunctors_ 为 true)，以避免新任务被延迟到下一轮 poll。</span><br><span class="line">     * </span><br><span class="line">     * @param cb 要投递的任务回调</span><br><span class="line">     */</span><br><span class="line">    void queueInLoop(Functor cb);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 唤醒 EventLoop 线程</span><br><span class="line">     * </span><br><span class="line">     * 通过向 wakeupFd_ 写入一个字节的数据，使阻塞在 poll() 上的 EventLoop 线程立即返回。</span><br><span class="line">     * 这是实现跨线程唤醒 EventLoop 的标准方法。</span><br><span class="line">     */</span><br><span class="line">    void wakeup();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 更新 Channel 的事件注册</span><br><span class="line">     * </span><br><span class="line">     * 此方法是 Channel 和 Poller 之间的桥梁。当 Channel 的感兴趣事件发生变化时，</span><br><span class="line">     * 它会调用此方法通知 Poller 更新其内部的数据结构 (如 epoll_ctl)。</span><br><span class="line">     * </span><br><span class="line">     * @param channel 需要更新的 Channel 对象</span><br><span class="line">     */</span><br><span class="line">    void updateChannel(Channel *channel);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 将 Channel 从 Poller 的监听列表中移除</span><br><span class="line">     * </span><br><span class="line">     * 当一个连接关闭时，TcpConnection 会调用此方法将其对应的 Channel 从 EventLoop 中注销。</span><br><span class="line">     * </span><br><span class="line">     * @param channel 需要移除的 Channel 对象</span><br><span class="line">     */</span><br><span class="line">    void removeChannel(Channel *channel);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 检查 EventLoop 是否正在监听某个特定的 Channel</span><br><span class="line">     * @param channel 要检查的 Channel 对象</span><br><span class="line">     * @return true 如果正在监听，false 否则</span><br><span class="line">     */</span><br><span class="line">    bool hasChannel(Channel *channel);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 检查当前调用线程是否是 EventLoop 所属的线程</span><br><span class="line">     * @return true 如果是，false 否则</span><br><span class="line">     */</span><br><span class="line">    bool isInLoopThread() const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    /**</span><br><span class="line">     * @brief wakeupFd_ 的读事件回调函数</span><br><span class="line">     * </span><br><span class="line">     * 当其他线程调用 wakeup() 向 wakeupFd_ 写入数据时，此回调会被触发。</span><br><span class="line">     * 它的主要工作是从 wakeupFd_ 中读取数据（通常是 8 字节），以清空内核缓冲区，</span><br><span class="line">     * 使 wakeupFd_ 可以再次用于唤醒。它本身不执行任何业务逻辑。</span><br><span class="line">     */</span><br><span class="line">    void handleRead();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @brief 执行 pendingFunctors_ 队列中的所有任务</span><br><span class="line">     * </span><br><span class="line">     * 为了避免在执行任务的过程中，任务队列被反复加锁（特别是当任务本身又调用 queueInLoop 时），</span><br><span class="line">     * 此函数采用了“ swap and dispatch ”的策略：</span><br><span class="line">     * 1. 用一个局部向量 functors 与 pendingFunctors_ 进行交换。</span><br><span class="line">     * 2. 解锁，这样其他线程可以继续向 pendingFunctors_ 中添加任务。</span><br><span class="line">     * 3. 遍历局部向量 functors 并执行其中的所有任务。</span><br><span class="line">     * </span><br><span class="line">     * callingPendingFunctors_ 标志在任务执行期间被设为 true，用于 queueInLoop 判断是否需要唤醒。</span><br><span class="line">     */</span><br><span class="line">    void doPendingFunctors();</span><br><span class="line"></span><br><span class="line">    // --- 成员变量 ---</span><br><span class="line"></span><br><span class="line">    /// @brief 标记事件循环是否正在运行</span><br><span class="line">    std::atomic_bool looping_;</span><br><span class="line"></span><br><span class="line">    /// @brief 标记是否需要退出事件循环</span><br><span class="line">    std::atomic_bool quit_;</span><br><span class="line"></span><br><span class="line">    /// @brief 记录当前 EventLoop 所属的线程 ID</span><br><span class="line">    const pid_t threadId_;</span><br><span class="line"></span><br><span class="line">    /// @brief 记录最近一次 poll() 返回的时间戳</span><br><span class="line">    Timestamp pollReturnTime_;</span><br><span class="line"></span><br><span class="line">    /// @brief 指向 Poller 对象的智能指针，由 EventLoop 唯一拥有</span><br><span class="line">    std::unique_ptr&lt;Poller&gt; poller_;</span><br><span class="line"></span><br><span class="line">    /// @brief 用于跨线程唤醒的文件描述符，由 eventfd() 创建</span><br><span class="line">    int wakeupFd_;</span><br><span class="line"></span><br><span class="line">    /// @brief 封装 wakeupFd_ 的 Channel 对象</span><br><span class="line">    std::unique_ptr&lt;Channel&gt; wakeupChannel_;</span><br><span class="line"></span><br><span class="line">    /// @brief 存储每次 poll() 返回的就绪 Channel 列表</span><br><span class="line">    ChannelList activeChannels_;</span><br><span class="line"></span><br><span class="line">    /// @brief 保护 pendingFunctors_ 的互斥锁</span><br><span class="line">    std::mutex mutex_;</span><br><span class="line"></span><br><span class="line">    /// @brief 存储等待被执行的任务队列</span><br><span class="line">    std::vector&lt;Functor&gt; pendingFunctors_;</span><br><span class="line"></span><br><span class="line">    /// @brief 标记当前是否正在执行 pendingFunctors_ 中的任务</span><br><span class="line">    /// 用于在 queueInLoop 中判断，当任务在执行期间又有新任务到来时，需要唤醒以避免延迟。</span><br><span class="line">    std::atomic_bool callingPendingFunctors_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上一共实现了三个模块的实现，Poller，Channel，EventLoop。</p>
<ol>
<li>EventLoop<br>角色：驱动循环的核心。它通过不断调用 Poller 监听事件，获取就绪事件后触发 Channel 的回调，<br>同时处理异步任务队列，是整个事件驱动流程的 “发动机”。</li>
<li>Poller<br>角色：事件监听器的结果获取者。它封装了 epoll 或 poll 等 I&#x2F;O 多路复用机制，<br>负责从操作系统层面获取哪些文件描述符（fd）发生了感兴趣的事件（如可读、可写），并将结果反馈给 EventLoop。</li>
<li>Channel<br>角色：fd 及其属性的封装者。<br>它将 fd、感兴趣的事件（如 EPOLLIN）、实际发生的事件（如 revents_）以及对应的回调函数（读、写、关闭、错误回调）整合在一起，<br>使得 fd 的事件管理和回调触发逻辑更加内聚，在 EventLoop 和 Poller 之间起到了 “桥梁” 作用，方便模块间的事件传递与处理。</li>
</ol>
<p><strong>One Loop Per Thresd含义引入</strong><br>每一个EventLoop都绑定了一个线程（一对一绑定），这种运行模式是Muduo库的特色充分利用了多核cpu的能力。<br>muduo 通过 “一线程一循环” 的设计，既利用了多核的性能，又简化了线程安全的复杂度 —— 这是它能成为高性能网络库的关键设计之一。</p>
<h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><p>Acceptor封装了服务器监听套接字fd以及相关处理方法，<br>这个类主要是对其他方法调用的封装</p>
<p>Acceptor 是 Reactor 模型中的连接接收器核心组件，专门负责监听指定端口、接收客户端新连接，并将连接分发交给上层处理（如 TcpServer），是 TCP 服务器接收连接的 “入口”。</p>
<p>作用： 监听端口 + 接受连接，屏蔽底层Socket，Channel的写作细节，<br>向上提供简洁的新连接回调接口</p>
<p>依赖 Socket：管理监听用的 socket（acceptSocket_），负责绑定、监听端口。<br>依赖 Channel：监听 acceptSocket_ 的读事件（有新连接时触发），并回调 handleRead() 处理。<br>依赖 EventLoop：运行在指定的事件循环中（通常是 mainLoop），由 EventLoop 驱动事件响应。</p>
<p><strong>Acceptor.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line">#include &quot;Socket.h&quot;</span><br><span class="line">#include &quot;Channel.h&quot;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line">class InetAddress;</span><br><span class="line"></span><br><span class="line">class Acceptor : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using NewConnectionCallback = std::function&lt;void(int sockfd, const InetAddress &amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    Acceptor(EventLoop *loop, const InetAddress &amp;listenAddr, bool reuseport);</span><br><span class="line">    ~Acceptor();</span><br><span class="line">    //设置新连接的回调函数</span><br><span class="line">    void setNewConnectionCallback(const NewConnectionCallback &amp;cb) &#123; NewConnectionCallback_ = cb; &#125;</span><br><span class="line">    // 判断是否在监听</span><br><span class="line">    bool listenning() const &#123; return listenning_; &#125;</span><br><span class="line">    // 监听本地端口</span><br><span class="line">    void listen();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void handleRead();//处理新用户的连接事件</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; // Acceptor用的就是用户定 义的那个baseLoop 也称作mainLoop</span><br><span class="line">    Socket acceptSocket_;//专门用于接收新连接的socket</span><br><span class="line">    Channel acceptChannel_;//专门用于监听新连接的channel</span><br><span class="line">    NewConnectionCallback NewConnectionCallback_;//新连接的回调函数</span><br><span class="line">    bool listenning_;//是否在监听</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Acceptor.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;Acceptor.h&quot;</span><br><span class="line">#include &quot;Logger.h&quot;</span><br><span class="line">#include &quot;InetAddress.h&quot;</span><br><span class="line"></span><br><span class="line">static int createNonblocking()</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">        SOCK_STREAM：TCP 流式协议（面向连接、可靠传输）。</span><br><span class="line">        SOCK_NONBLOCK：设置 fd 为非阻塞模式，避免 accept 等操作阻塞 EventLoop。</span><br><span class="line">        SOCK_CLOEXEC：进程执行 exec 系统调用时自动关闭该 fd，避免 fd 泄漏到子进程。</span><br><span class="line">    */</span><br><span class="line">    int sockfd = ::socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">    if (sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_FATAL(&quot;%s:%s:%d listen socket create err:%d\n&quot;, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">    &#125;</span><br><span class="line">    return sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::Acceptor(EventLoop *loop, const InetAddress &amp;listenAddr, bool reuseport)</span><br><span class="line">    : loop_(loop)</span><br><span class="line">    , acceptSocket_(createNonblocking())  // 初始化监听socket</span><br><span class="line">    , acceptChannel_(loop, acceptSocket_.fd()) // 绑定loop和监听 fd</span><br><span class="line">    , listenning_(false) </span><br><span class="line">&#123;</span><br><span class="line">    acceptSocket_.setReuseAddr(true);   </span><br><span class="line">    acceptSocket_.setReusePort(true);</span><br><span class="line">    acceptSocket_.bindAddress(listenAddr); // 绑定监听地址</span><br><span class="line">    // TcpServer::start() =&gt; Acceptor.listen() 如果有新用户连接 要执行一个回调(accept =&gt; connfd =&gt; 打包成Channel =&gt; 唤醒subloop)</span><br><span class="line">    // baseloop监听到有事件发生 =&gt; acceptChannel_(listenfd) =&gt; 执行该回调函数</span><br><span class="line">    acceptChannel_.setReadCallback(</span><br><span class="line">        std::bind(&amp;Acceptor::handleRead, this));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~Acceptor()</span><br><span class="line">&#123;</span><br><span class="line">    acceptChannel_.disableAll();    // 把从Poller中感兴趣的事件删除掉</span><br><span class="line">    acceptChannel_.remove();        // 调用EventLoop-&gt;removeChannel =&gt; Poller-&gt;removeChannel 把Poller的ChannelMap对应的部分删除</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Acceptor::listen()</span><br><span class="line">&#123;</span><br><span class="line">    listenning_ = true;</span><br><span class="line">    acceptSocket_.listen();         // listen</span><br><span class="line">    acceptChannel_.enableReading(); // acceptChannel_注册至Poller !重要</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// listenfd有事件发生了，就是有新用户连接了</span><br><span class="line">void Acceptor::handleRead()</span><br><span class="line">&#123;</span><br><span class="line">    InetAddress peerAddr;  //存客户端地址</span><br><span class="line">    int connfd = acceptSocket_.accept(&amp;peerAddr);</span><br><span class="line">    if (connfd &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (NewConnectionCallback_) // 如果设置了回调</span><br><span class="line">        &#123;</span><br><span class="line">            NewConnectionCallback_(connfd, peerAddr); // 轮询找到subLoop 唤醒并分发当前的新客户端的Channel</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ::close(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(&quot;%s:%s:%d accept err:%d\n&quot;, __FILE__, __FUNCTION__, __LINE__, errno);</span><br><span class="line">        if (errno == EMFILE)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_ERROR(&quot;%s:%s:%d sockfd reached limit\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="补充工具类-Buffer"><a href="#补充工具类-Buffer" class="headerlink" title="补充工具类 Buffer"></a>补充工具类 Buffer</h2><p>Buffer 类是网络编程中一种高效的内存缓冲区管理工具，核心设计目标是减少内存拷贝、优化 I&#x2F;O 操作性能，同时提供安全、便捷的读写接口。</p>
<p><strong>核心设计思想</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Buffer 的设计基于 “预分配 + 读写索引分离 + 动态扩容” 模式，解决了直接使用 std::vector 或 C 数组的三大痛点：</span><br><span class="line">减少内存拷贝：通过读写索引分离，避免每次读写后的数据移动（如读取数据后无需 memcpy 前移剩余数据）；</span><br><span class="line">优化 I/O 效率：预留 kCheapPrepend 空间，适配 TCP 协议头（如在数据前添加长度字段），同时支持从 fd 直接读写（readFd/writeFd），减少系统调用次数；</span><br><span class="line">动态扩容策略：根据需要自动调整缓冲区大小，平衡内存占用和扩容开销</span><br></pre></td></tr></table></figure>

<p><strong>Buffer.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">// 网络库底层的缓冲区类型定义</span><br><span class="line">class Buffer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static const size_t kCheapPrepend = 8;//初始预留的prependabel空间大小</span><br><span class="line">    static const size_t kInitialSize = 1024; // </span><br><span class="line"></span><br><span class="line">    explicit Buffer(size_t initalSize = kInitialSize)</span><br><span class="line">        : buffer_(kCheapPrepend + initalSize)</span><br><span class="line">        , readerIndex_(kCheapPrepend)</span><br><span class="line">        , writerIndex_(kCheapPrepend)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可读数据长度</span><br><span class="line">    size_t readableBytes() const &#123; return writerIndex_ - readerIndex_; &#125;</span><br><span class="line">    // 可写空间长度</span><br><span class="line">    size_t writableBytes() const &#123; return buffer_.size() - writerIndex_; &#125;</span><br><span class="line">    //前置预留空间长度</span><br><span class="line">    size_t prependableBytes() const &#123; return readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    // 返回缓冲区中可读数据的起始地址</span><br><span class="line">    const char *peek() const &#123; return begin() + readerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    // 读取指定长度数据</span><br><span class="line">    void retrieve(size_t len)</span><br><span class="line">    &#123;</span><br><span class="line">        if (len &lt; readableBytes())</span><br><span class="line">        &#123;</span><br><span class="line">            readerIndex_ += len; // 说明应用只读取了可读缓冲区数据的一部分，就是len长度 还剩下readerIndex+=len到writerIndex_的数据未读</span><br><span class="line">        &#125;</span><br><span class="line">        else // len == readableBytes()</span><br><span class="line">        &#123;</span><br><span class="line">            retrieveAll(); // 读完所有数据，复位缓冲区</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 读完所有数据，复位缓冲区</span><br><span class="line">    void retrieveAll()</span><br><span class="line">    &#123;</span><br><span class="line">        readerIndex_ = kCheapPrepend;</span><br><span class="line">        writerIndex_ = kCheapPrepend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 把onMessage函数上报的Buffer数据 转成string类型的数据返回</span><br><span class="line">    std::string retrieveAllAsString() &#123; return retrieveAsString(readableBytes()); &#125;</span><br><span class="line"></span><br><span class="line">    // 读取数据并转为字符串</span><br><span class="line">    std::string retrieveAsString(size_t len)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string result(peek(), len);</span><br><span class="line">        retrieve(len); // 上面一句把缓冲区中可读的数据已经读取出来 这里肯定要对缓冲区进行复位操作</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // buffer_.size - writerIndex_</span><br><span class="line">    void ensureWritableBytes(size_t len)</span><br><span class="line">    &#123;</span><br><span class="line">        if (writableBytes() &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            makeSpace(len); // 扩容</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 把[data, data+len]内存上的数据添加到writable缓冲区当中</span><br><span class="line">    void append(const char *data, size_t len)</span><br><span class="line">    &#123;</span><br><span class="line">        ensureWritableBytes(len);</span><br><span class="line">        std::copy(data, data+len, beginWrite());</span><br><span class="line">        writerIndex_ += len;</span><br><span class="line">    &#125;</span><br><span class="line">    char *beginWrite() &#123; return begin() + writerIndex_; &#125;</span><br><span class="line">    const char *beginWrite() const &#123; return begin() + writerIndex_; &#125;</span><br><span class="line"></span><br><span class="line">    // 从fd上读取数据</span><br><span class="line">    ssize_t readFd(int fd, int *saveErrno);</span><br><span class="line">    // 通过fd发送数据</span><br><span class="line">    ssize_t writeFd(int fd, int *saveErrno);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // vector底层数组首元素的地址 也就是数组的起始地址</span><br><span class="line">    char *begin() &#123; return &amp;*buffer_.begin(); &#125;</span><br><span class="line">    const char *begin() const &#123; return &amp;*buffer_.begin(); &#125;</span><br><span class="line"></span><br><span class="line">    void makeSpace(size_t len)</span><br><span class="line">    &#123;</span><br><span class="line">        /**</span><br><span class="line">         * | kCheapPrepend |xxx| reader | writer |                     // xxx标示reader中已读的部分</span><br><span class="line">         * | kCheapPrepend | reader ｜          len          |</span><br><span class="line">         **/</span><br><span class="line">        if (writableBytes() + prependableBytes() &lt; len + kCheapPrepend) // 也就是说 len &gt; xxx前面剩余的空间 + writer的部分</span><br><span class="line">        &#123;</span><br><span class="line">            buffer_.resize(writerIndex_ + len);</span><br><span class="line">        &#125;</span><br><span class="line">        else // 这里说明 len &lt;= xxx + writer 把reader搬到从xxx开始 使得xxx后面是一段连续空间</span><br><span class="line">        &#123;</span><br><span class="line">            size_t readable = readableBytes(); // readable = reader的长度</span><br><span class="line">            // 将当前缓冲区中从readerIndex_到writerIndex_的数据</span><br><span class="line">            // 拷贝到缓冲区起始位置kCheapPrepend处，以便腾出更多的可写空间</span><br><span class="line">            std::copy(begin() + readerIndex_,</span><br><span class="line">                      begin() + writerIndex_,</span><br><span class="line">                      begin() + kCheapPrepend);</span><br><span class="line">            readerIndex_ = kCheapPrepend;</span><br><span class="line">            writerIndex_ = readerIndex_ + readable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;char&gt; buffer_;</span><br><span class="line">    size_t readerIndex_;</span><br><span class="line">    size_t writerIndex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h2><p>在多线程网络编程中，为了充分利用多核 CPU，通常会采用主从 Reactor 模型或多 Reactor 模型。EventLoopThread 就是用来创建 “从 Reactor”（Sub Reactor）的工具。</p>
<p>EventLoopThread 是一个将EventLoop和线程绑定在一起的辅助类，核心作用是<br>创建一个新线程，并在这个线程启动一个EventLoop的事件循环，这是实现One Loop Per Thread<br>模型的关键组件</p>
<p><strong>EventLoopThread.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line">#include &quot;Thread.h&quot;</span><br><span class="line"></span><br><span class="line">class EventLoop;</span><br><span class="line"></span><br><span class="line">class EventLoopThread : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using ThreadInitCallback = std::function&lt;void(EventLoop *)&gt;;</span><br><span class="line"></span><br><span class="line">    EventLoopThread(const ThreadInitCallback &amp;cb = ThreadInitCallback(),</span><br><span class="line">                    const std::string &amp;name = std::string());</span><br><span class="line">    ~EventLoopThread();</span><br><span class="line">    </span><br><span class="line">    EventLoop *startLoop(); // 主线程执行startLoop，创建新线程，开启loop</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    /*</span><br><span class="line">    核心流程（新线程独立执行）：</span><br><span class="line">    创建 EventLoop 对象：在新线程的栈上分配，生命周期与线程绑定，无需手动释放。</span><br><span class="line">    执行初始化回调：若用户设置了 ThreadInitCallback，在 loop() 启动前执行（如注册初始 Channel、设置线程局部存储等）。</span><br><span class="line">    同步主线程：加锁后给 loop_ 赋值，通过条件变量唤醒主线程，让主线程获取 EventLoop 指针。</span><br><span class="line">    启动事件循环：调用 loop.loop()，进入无限循环（监听 Poller 事件、处理回调），直到 loop.quit() 被调用。</span><br><span class="line">    循环退出后重置 loop_：避免主线程通过已失效的 loop_ 指针操作。</span><br><span class="line">    */</span><br><span class="line">    void threadFunc(); // 创建并执行EventLoop</span><br><span class="line"></span><br><span class="line">    EventLoop *loop_; // 指向本线程中创建的 EventLoop 对象</span><br><span class="line">    bool exiting_; // 标记线程是否正在退出</span><br><span class="line">    Thread thread_;  // 封装了线程的创建和线程的启动</span><br><span class="line">    /*</span><br><span class="line">    用 std::mutex + std::condition_variable 解决 “主线程等待新线程初始化 EventLoop” 的同步问题。</span><br><span class="line">    cond_.wait() 带条件判断（loop_ != nullptr），避免虚假唤醒（如系统信号导致的误唤醒）。</span><br><span class="line">    */</span><br><span class="line">    std::mutex mutex_;             // 互斥锁</span><br><span class="line">    std::condition_variable cond_; // 条件变量</span><br><span class="line">    ThreadInitCallback callback_;  // 线程初始化回调函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>细节实现<br><strong>EventLoopThread.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;EventLoopThread.h&quot;</span><br><span class="line">#include &quot;EventLoop.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">初始化成员变量：loop_（指向线程内的 EventLoop）设为 nullptr，exiting_（退出标志）设为 false。</span><br><span class="line">初始化线程对象 thread_：通过 std::bind 将 threadFunc（线程入口函数）与当前对象绑定，同时指定线程名称（方便调试日志）。</span><br><span class="line">保存线程初始化回调 callback_：用于 EventLoop 启动前的自定义初始化。</span><br><span class="line">*/</span><br><span class="line">EventLoopThread::EventLoopThread(const ThreadInitCallback &amp;cb,</span><br><span class="line">                                 const std::string &amp;name)</span><br><span class="line">    : loop_(nullptr)</span><br><span class="line">    , exiting_(false)</span><br><span class="line">    , thread_(std::bind(&amp;EventLoopThread::threadFunc, this), name)</span><br><span class="line">    , mutex_()</span><br><span class="line">    , cond_()</span><br><span class="line">    , callback_(cb)</span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThread::~EventLoopThread()</span><br><span class="line">&#123;</span><br><span class="line">    exiting_ = true;</span><br><span class="line">    if (loop_ != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        loop_-&gt;quit(); // 通知EventLoop退出事件循环</span><br><span class="line">        thread_.join(); // 等待线程执行完毕，避免资源泄漏</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoop *EventLoopThread::startLoop()</span><br><span class="line">&#123;</span><br><span class="line">    thread_.start(); // 启用底层线程Thread类对象thread_中通过start()创建的线程</span><br><span class="line"></span><br><span class="line">    EventLoop *loop = nullptr;</span><br><span class="line">    &#123;</span><br><span class="line">        // 加锁等待</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</span><br><span class="line">        cond_.wait(lock, [this]()&#123;return loop_ != nullptr;&#125;);</span><br><span class="line">        loop = loop_;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下面这个方法 是在单独的新线程里运行的</span><br><span class="line">void EventLoopThread::threadFunc()</span><br><span class="line">&#123;</span><br><span class="line">    EventLoop loop; // 创建一个独立的EventLoop对象 和上面的线程是一一对应的 级one loop per thread</span><br><span class="line"></span><br><span class="line">    // 初始化回调函数，如果有</span><br><span class="line">    if (callback_)</span><br><span class="line">    &#123;</span><br><span class="line">        callback_(&amp;loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        // 加锁</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</span><br><span class="line">        loop_ = &amp;loop;</span><br><span class="line">        // 通知</span><br><span class="line">        cond_.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">    loop.loop();    // 执行EventLoop的loop() 开启了底层的Poller的poll()</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock(mutex_);</span><br><span class="line">    loop_ = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventLoopThreadPool"><a href="#EventLoopThreadPool" class="headerlink" title="EventLoopThreadPool"></a>EventLoopThreadPool</h2><p>EventLoopThreadPool 是 muduo 网络库中实现 “主从 Reactor 模型” 的核心组件，它管理着一组 EventLoopThread，为 TcpServer 提供可复用的 I&#x2F;O 线程池。<br>它的核心功能是：<br>创建线程：根据设定的线程数，创建多个 EventLoopThread。<br>管理 EventLoop：管理所有子线程创建的 EventLoop 对象。<br>负载均衡：提供 getNextLoop() 方法，采用轮询（Round-Robin）策略，将新接收到的连接均匀地分配给线程池中的某个 EventLoop，从而实现多线程并发处理 I&#x2F;O 事件。</p>
<p><strong>EventLoopThreadPool.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;noncopyable.h&quot;</span><br><span class="line">class EventLoop;</span><br><span class="line">class EventLoopThread;</span><br><span class="line"> </span><br><span class="line">class EventLoopThreadPool : noncopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using ThreadInitCallback = std::function&lt;void(EventLoop *)&gt;;</span><br><span class="line"></span><br><span class="line">    EventLoopThreadPool(EventLoop *baseLoop, const std::string &amp;nameArg);</span><br><span class="line">    ~EventLoopThreadPool();</span><br><span class="line"></span><br><span class="line">    void setThreadNum(int numThreads) &#123; numThreads_ = numThreads; &#125;</span><br><span class="line"></span><br><span class="line">    void start(const ThreadInitCallback &amp;cb = ThreadInitCallback());</span><br><span class="line"></span><br><span class="line">    // 如果工作在多线程中，baseLoop_(mainLoop)会默认以轮询的方式分配Channel给subLoop</span><br><span class="line">    EventLoop *getNextLoop();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;EventLoop *&gt; getAllLoops(); // 获取所有的EventLoop</span><br><span class="line"></span><br><span class="line">    bool started() const &#123; return started_; &#125; // 是否已经启动</span><br><span class="line">    const std::string name() const &#123; return name_; &#125; // 获取名字</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    EventLoop *baseLoop_; // 用户使用muduo创建的loop 如果线程数为1 那直接使用用户创建的loop 否则创建多EventLoop</span><br><span class="line">    std::string name_;//线程池名称，通常由用户指定，线程池中EventLoopThread名称依赖于线程池名称。</span><br><span class="line">    bool started_;//是否已经启动标志</span><br><span class="line">    int numThreads_;//线程池中线程的数量</span><br><span class="line">    int next_; // 新连接到来，所选择EventLoop的索引</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; threads_;//IO线程的列表</span><br><span class="line">    std::vector&lt;EventLoop *&gt; loops_;//线程池中EventLoop的列表，指向的是EVentLoopThread线程函数创建的EventLoop对象。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>EventLoopSThreadPool.cc</strong></p>
<ol>
<li>灵活的线程模式支持<br>多线程模式：通过 setThreadNum(n) 设置线程数（n&gt;0），创建 n 个 Sub Reactor，并发处理 I&#x2F;O 事件。<br>单线程模式：线程数设为 0，所有操作都在 baseLoop_ 执行，适配简单场景。</li>
<li>安全的资源管理<br>用 std::unique_ptr 管理 EventLoopThread，自动处理线程生命周期，避免内存泄漏。<br>EventLoop 基于栈分配，线程退出时自动析构，无需手动管理，减少出错风险。</li>
<li>高效的负载均衡<br>轮询策略（getNextLoop()）简单无锁（next_ 仅在主线程修改，因为 getNextLoop() 由 TcpServer 在主线程调用），性能开销极低。<br>确保每个 Sub Reactor 处理的连接数大致均衡，充分利用多核 CPU 资源。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line"> </span><br><span class="line">#include &quot;EventLoopThreadPool.h&quot;</span><br><span class="line">#include &quot;EventLoopThread.h&quot;</span><br><span class="line">#include &quot;Logger.h&quot;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">保存主循环 baseLoop_（主线程的 EventLoop，即 Main Reactor）。</span><br><span class="line">保存线程池名称 name_（用于调试日志，区分不同线程池）。</span><br><span class="line">初始化状态变量：started_（是否启动）设为 false，numThreads_（线程数）初始为 0，next_（轮询索引）初始为 0。</span><br><span class="line">*/</span><br><span class="line">EventLoopThreadPool::EventLoopThreadPool(EventLoop *baseLoop, const std::string &amp;nameArg)</span><br><span class="line">    : baseLoop_(baseLoop), name_(nameArg), started_(false), numThreads_(0), next_(0)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventLoopThreadPool::~EventLoopThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    // Don&#x27;t delete loop, it&#x27;s stack variable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void EventLoopThreadPool::start(const ThreadInitCallback &amp;cb)</span><br><span class="line">&#123;</span><br><span class="line">    started_ = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; numThreads_; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[name_.size() + 32];</span><br><span class="line">        snprintf(buf, sizeof buf, &quot;%s%d&quot;, name_.c_str(), i); // 生成线程名</span><br><span class="line">        EventLoopThread *t = new EventLoopThread(cb, buf); // 创建EventLoopThread</span><br><span class="line">        threads_.push_back(std::unique_ptr&lt;EventLoopThread&gt;(t)); // 智能指针管理，避免泄漏</span><br><span class="line">        loops_.push_back(t-&gt;startLoop()); // 底层创建线程 绑定一个新的EventLoop 并返回该loop的地址</span><br><span class="line">    &#125;</span><br><span class="line">    // 单线程模式：线程数为 0，直接在 baseLoop_ 执行初始化回调</span><br><span class="line">    if (numThreads_ == 0 &amp;&amp; cb) // 整个服务端只有一个线程运行baseLoop</span><br><span class="line">    &#123;</span><br><span class="line">        cb(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果工作在多线程中，baseLoop_(mainLoop)会默认以轮询的方式分配Channel给subLoop</span><br><span class="line">EventLoop *EventLoopThreadPool::getNextLoop()</span><br><span class="line">&#123;</span><br><span class="line">    // 如果只设置一个线程 也就是只有一个mainReactor 无subReactor </span><br><span class="line">    // 那么轮询只有一个线程 getNextLoop()每次都返回当前的baseLoop_</span><br><span class="line">    EventLoop *loop = baseLoop_;    </span><br><span class="line"></span><br><span class="line">    // 通过轮询获取下一个处理事件的loop</span><br><span class="line">    // 如果没设置多线程数量，则不会进去，相当于直接返回baseLoop</span><br><span class="line">    if(!loops_.empty())             </span><br><span class="line">    &#123;</span><br><span class="line">        loop = loops_[next_];</span><br><span class="line">        ++next_;</span><br><span class="line">        // 轮询</span><br><span class="line">        if(next_ &gt;= loops_.size())  // 索引越界后重置，实现轮询</span><br><span class="line">        &#123;</span><br><span class="line">            next_ = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">std::vector&lt;EventLoop *&gt; EventLoopThreadPool::getAllLoops()</span><br><span class="line">&#123;</span><br><span class="line">    if (loops_.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return std::vector&lt;EventLoop *&gt;(1, baseLoop_); // 单线程模式：返回包含 baseLoop_ 的列表</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return loops_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><p><strong>.h</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">class Buffer;</span><br><span class="line">class TcpConnection;</span><br><span class="line">class Timestamp;</span><br><span class="line"></span><br><span class="line">using TcpConnectionPtr = std::shared_ptr&lt;TcpConnection&gt;;</span><br><span class="line">using ConnectionCallback = std::function&lt;void(const TcpConnectionPtr &amp;)&gt;;</span><br><span class="line">using CloseCallback = std::function&lt;void(const TcpConnectionPtr &amp;)&gt;;</span><br><span class="line">using WriteCompleteCallback = std::function&lt;void(const TcpConnectionPtr &amp;)&gt;;</span><br><span class="line">using HighWaterMarkCallback = std::function&lt;void(const TcpConnectionPtr &amp;, size_t)&gt;;</span><br><span class="line"></span><br><span class="line">using MessageCallback = std::function&lt;void(const TcpConnectionPtr &amp;,</span><br><span class="line">                                           Buffer *,</span><br><span class="line">                                           Timestamp)&gt;;</span><br></pre></td></tr></table></figure>



<h2 id="TcpConection"><a href="#TcpConection" class="headerlink" title="TcpConection"></a>TcpConection</h2><h2 id="TcpServer"><a href="#TcpServer" class="headerlink" title="TcpServer"></a>TcpServer</h2><h2 id="testserver"><a href="#testserver" class="headerlink" title="testserver"></a>testserver</h2><p>简单的回显来测试muduo<br><strong>&#x2F;example&#x2F;testserver.cc</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;TcpServer.h&quot;</span><br><span class="line">#include &quot;Logger.h&quot;</span><br><span class="line"></span><br><span class="line">class EchoServer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    EchoServer(EventLoop *loop, const InetAddress &amp;addr, const std::string &amp;name)</span><br><span class="line">        : server_(loop, addr, name)</span><br><span class="line">        , loop_(loop)</span><br><span class="line">    &#123;</span><br><span class="line">        // 注册回调函数 </span><br><span class="line">        server_.setConnectionCallback(</span><br><span class="line">            std::bind(&amp;EchoServer::onConnection, this, std::placeholders::_1));</span><br><span class="line">        </span><br><span class="line">        server_.setMessageCallback(</span><br><span class="line">            std::bind(&amp;EchoServer::onMessage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">        // 设置合适的subloop线程数量</span><br><span class="line">        server_.setThreadNum(3);</span><br><span class="line">    &#125;</span><br><span class="line">    void start()</span><br><span class="line">    &#123;</span><br><span class="line">        server_.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 连接建立或断开的回调函数</span><br><span class="line">    void onConnection(const TcpConnectionPtr &amp;conn)   </span><br><span class="line">    &#123;</span><br><span class="line">        if (conn-&gt;connected()) </span><br><span class="line">        &#123;</span><br><span class="line">            conn-&gt;send(&quot;Welcome to EchoServer!\n&quot;);</span><br><span class="line">            LOG_INFO(&quot;Connection UP : %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_INFO(&quot;Connection DOWN : %s&quot;, conn-&gt;peerAddress().toIpPort().c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可读写事件回调 </span><br><span class="line">    void onMessage(const TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp time)</span><br><span class="line">    &#123;</span><br><span class="line">        std::string msg = buf-&gt;retrieveAllAsString();</span><br><span class="line">        conn-&gt;send(msg);</span><br><span class="line">        // conn-&gt;shutdown();   // 关闭写端 底层响应EPOLLHUP =&gt; 执行closeCallback_</span><br><span class="line">    &#125;</span><br><span class="line">    TcpServer server_;</span><br><span class="line">    EventLoop *loop_;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    EventLoop loop;</span><br><span class="line">    InetAddress addr(8080);</span><br><span class="line">    EchoServer server(&amp;loop, addr, &quot;EchoServer&quot;);</span><br><span class="line">    server.start();</span><br><span class="line">    loop.loop();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>send发送信息流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">muduo-core 项目内部流程：</span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│ testserver.cc (应用层)                                      │</span><br><span class="line">│ └── conn-&gt;send(&quot;Welcome to EchoServer!\n&quot;)                 │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│ TcpConnection.cc (连接管理层)                               │</span><br><span class="line">│ ├── TcpConnection::send()                                  │</span><br><span class="line">│ ├── TcpConnection::sendInLoop()                            │</span><br><span class="line">│ └── ::write(channel_-&gt;fd(), data, len)  ← 系统调用        │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Buffer.cc (缓冲区管理层)                                    │</span><br><span class="line">│ ├── outputBuffer_.append()                                 │</span><br><span class="line">│ └── Buffer::writeFd() → ::write()                         │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│ Channel.cc + EventLoop.cc (事件处理层)                     │</span><br><span class="line">│ ├── Channel::handleEvent()                                 │</span><br><span class="line">│ ├── Channel::handleWrite()                                 │</span><br><span class="line">│ └── epoll 事件循环                                         │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br><span class="line">                            ↓</span><br><span class="line">                    系统调用 write()</span><br><span class="line">                            ↓</span><br><span class="line">                      内核网络协议栈</span><br><span class="line">                            ↓</span><br><span class="line">                        网卡发送</span><br><span class="line"></span><br><span class="line">muduo-core 项目边界：::write(fd, data, len)</span><br><span class="line">                    ↓</span><br><span class="line">            Linux 内核网络协议栈</span><br><span class="line">                    ↓</span><br><span class="line">                TCP/IP 处理</span><br><span class="line">                    ↓</span><br><span class="line">                网卡驱动</span><br><span class="line">                    ↓</span><br><span class="line">            物理网络传输 (以太网/WiFi)</span><br><span class="line">                    ↓</span><br><span class="line">            客户端网卡接收</span><br><span class="line">                    ↓</span><br><span class="line">            客户端内核协议栈</span><br><span class="line">                    ↓</span><br><span class="line">        客户端应用程序 (telnet/浏览器/自定义程序)</span><br><span class="line">                    ↓</span><br><span class="line">        客户端程序调用 printf/cout/write(STDOUT)</span><br><span class="line">                    ↓</span><br><span class="line">            终端驱动程序</span><br><span class="line">                    ↓</span><br><span class="line">            显示器硬件 ← 最终显示</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      
      
      
      
      
      
      
      

    </footer>
  </div>
  
  <nav id="article-nav" data-aos="fade-up">
    
      <div class="article-nav-link-wrap article-nav-link-left">
        
          
          
            <img data-src="/images/banner.webp" data-sizes="auto" alt="cmake，一款项目构建工具" class="lazyload">
          
        
        <a href="/2025/11/22/cmake%EF%BC%8C%E4%B8%80%E6%AC%BE%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
          
            cmake，一款项目构建工具
          
        </h3>
      </div>
    
    
    <div class="article-nav-link-wrap article-nav-link-right">
      
        
        
          <img data-src="/images/banner.webp" data-sizes="auto" alt="Linux_7 线程" class="lazyload">
        
      
      <a href="/2025/09/27/Linux_7-%E7%BA%BF%E7%A8%8B/"></a>
      <div class="article-nav-caption">后一篇</div>
      <h3 class="article-nav-title">
        
          Linux_7 线程
        
      </h3>
    </div>
    
  </nav>


</article>






</section>
          
            <aside id="sidebar">
  
  
  <div class="sidebar-wrapper wrap-sticky">
    <div class="sidebar-wrap" data-aos="fade-up">
      
        <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">项目核心组件关系与数据流向图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%85%B3%E8%81%94%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">核心组件关联总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">2.</span> <span class="toc-text">项目前置工具实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#noncopyable-%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">noncopyable 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">日志工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E7%96%AF%E6%B6%A8"><span class="toc-number">2.3.</span> <span class="toc-text">对时间戳的疯涨</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">线程相关实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CurrentThread"><span class="toc-number">2.4.1.</span> <span class="toc-text">CurrentThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">2.4.2.</span> <span class="toc-text">Thread 线程的封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress-%E5%92%8C-Socket"><span class="toc-number">2.5.</span> <span class="toc-text">InetAddress 和 Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress"><span class="toc-number">2.5.1.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">2.5.2.</span> <span class="toc-text">Socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%87%8D%E7%82%B9%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">3.</span> <span class="toc-text">项目重点类实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">3.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%BB%BD%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E4%BD%93%E7%8E%B0%E4%BA%86-Channel-%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3%EF%BC%9A%E5%B0%81%E8%A3%85-fd-%E5%92%8C%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%84%9F%E5%85%B4%E8%B6%A3%E4%BA%8B%E4%BB%B6-events-%E3%80%81%E5%AE%9E%E9%99%85%E5%8F%91%E7%94%9F%E4%BA%8B%E4%BB%B6-revents-%EF%BC%89%EF%BC%9B%E6%8F%90%E4%BE%9B%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E6%97%B6%E6%8C%89%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E5%8F%91%E5%9B%9E%E8%B0%83%EF%BC%9B%E9%80%9A%E8%BF%87-tie-%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8A%A4%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%EF%BC%9B%E5%A7%94%E6%89%98-EventLoop-%E4%B8%8E-Poller-%E4%BA%A4%E4%BA%92%EF%BC%8C%E8%A7%A3%E8%80%A6%E5%BA%95%E5%B1%82-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">这份实现完整体现了 Channel 类的核心职责：封装 fd 和事件（感兴趣事件 events_、实际发生事件 revents_）；提供回调注册接口，在事件发生时按优先级分发回调；通过 tie 机制保护对象生命周期，避免野指针访问；委托 EventLoop 与 Poller 交互，解耦底层 I&#x2F;O 多路复用实现。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Poller"><span class="toc-number">3.3.</span> <span class="toc-text">Poller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EPollPoller-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">EPollPoller 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoop"><span class="toc-number">3.5.</span> <span class="toc-text">EventLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acceptor"><span class="toc-number">3.6.</span> <span class="toc-text">Acceptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E5%B7%A5%E5%85%B7%E7%B1%BB-Buffer"><span class="toc-number">3.7.</span> <span class="toc-text">补充工具类 Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThread"><span class="toc-number">3.8.</span> <span class="toc-text">EventLoopThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThreadPool"><span class="toc-number">3.9.</span> <span class="toc-text">EventLoopThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callback"><span class="toc-number">3.10.</span> <span class="toc-text">Callback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpConection"><span class="toc-number">3.11.</span> <span class="toc-text">TcpConection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpServer"><span class="toc-number">3.12.</span> <span class="toc-text">TcpServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#testserver"><span class="toc-number">3.13.</span> <span class="toc-text">testserver</span></a></li></ol></li></ol>
      
  </div>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="nilv" class="lazyload">
  <div class="sidebar-author-name">nilv</div>
  <div class="sidebar-description">希望你能得到些什么</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">28</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">0</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
      
      
        <div class="sidebar-btn-wrapper" style="position:static">
          <div class="sidebar-toc-btn current"></div>
          <div class="sidebar-common-btn"></div>
        </div>
      
    </div>
  </div>

  <div class="sidebar-widget">
  
  </div>
</aside>

          
        </div>
        <footer id="footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    
    <div>
      <span class="icon-copyright"></span>
      2020-2025
      <span class="footer-info-sep rotate"></span>
      nilv
    </div>
    
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener external nofollow noreferrer" target="_blank">Reimu</a>
      </div>
    
    
      <div>
        <span class="icon-brush"></span>
        48.3k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        03:40
      </div>
    
    
    
    
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
    
  </div>
</footer>

        
          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav">
  <div class="sidebar-wrap">
    
      <div class="sidebar-toc-sidebar"><div class="sidebar-toc">
  <h3 class="toc-title">文章目录</h3>
  <div class="sidebar-toc-wrapper toc-div-class" >
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">项目核心组件关系与数据流向图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%85%B3%E8%81%94%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">核心组件关联总览</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%BD%AE%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">2.</span> <span class="toc-text">项目前置工具实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#noncopyable-%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">noncopyable 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">日志工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E7%96%AF%E6%B6%A8"><span class="toc-number">2.3.</span> <span class="toc-text">对时间戳的疯涨</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.4.</span> <span class="toc-text">线程相关实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CurrentThread"><span class="toc-number">2.4.1.</span> <span class="toc-text">CurrentThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">2.4.2.</span> <span class="toc-text">Thread 线程的封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InetAddress-%E5%92%8C-Socket"><span class="toc-number">2.5.</span> <span class="toc-text">InetAddress 和 Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress"><span class="toc-number">2.5.1.</span> <span class="toc-text">InetAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket"><span class="toc-number">2.5.2.</span> <span class="toc-text">Socket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%87%8D%E7%82%B9%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">3.</span> <span class="toc-text">项目重点类实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">3.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%BB%BD%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E4%BD%93%E7%8E%B0%E4%BA%86-Channel-%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3%EF%BC%9A%E5%B0%81%E8%A3%85-fd-%E5%92%8C%E4%BA%8B%E4%BB%B6%EF%BC%88%E6%84%9F%E5%85%B4%E8%B6%A3%E4%BA%8B%E4%BB%B6-events-%E3%80%81%E5%AE%9E%E9%99%85%E5%8F%91%E7%94%9F%E4%BA%8B%E4%BB%B6-revents-%EF%BC%89%EF%BC%9B%E6%8F%90%E4%BE%9B%E5%9B%9E%E8%B0%83%E6%B3%A8%E5%86%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E6%97%B6%E6%8C%89%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E5%8F%91%E5%9B%9E%E8%B0%83%EF%BC%9B%E9%80%9A%E8%BF%87-tie-%E6%9C%BA%E5%88%B6%E4%BF%9D%E6%8A%A4%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%EF%BC%9B%E5%A7%94%E6%89%98-EventLoop-%E4%B8%8E-Poller-%E4%BA%A4%E4%BA%92%EF%BC%8C%E8%A7%A3%E8%80%A6%E5%BA%95%E5%B1%82-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">这份实现完整体现了 Channel 类的核心职责：封装 fd 和事件（感兴趣事件 events_、实际发生事件 revents_）；提供回调注册接口，在事件发生时按优先级分发回调；通过 tie 机制保护对象生命周期，避免野指针访问；委托 EventLoop 与 Poller 交互，解耦底层 I&#x2F;O 多路复用实现。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Poller"><span class="toc-number">3.3.</span> <span class="toc-text">Poller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EPollPoller-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.</span> <span class="toc-text">EPollPoller 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoop"><span class="toc-number">3.5.</span> <span class="toc-text">EventLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Acceptor"><span class="toc-number">3.6.</span> <span class="toc-text">Acceptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E5%B7%A5%E5%85%B7%E7%B1%BB-Buffer"><span class="toc-number">3.7.</span> <span class="toc-text">补充工具类 Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThread"><span class="toc-number">3.8.</span> <span class="toc-text">EventLoopThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoopThreadPool"><span class="toc-number">3.9.</span> <span class="toc-text">EventLoopThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callback"><span class="toc-number">3.10.</span> <span class="toc-text">Callback</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpConection"><span class="toc-number">3.11.</span> <span class="toc-text">TcpConection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TcpServer"><span class="toc-number">3.12.</span> <span class="toc-text">TcpServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#testserver"><span class="toc-number">3.13.</span> <span class="toc-text">testserver</span></a></li></ol></li></ol>
      
  </div>
</div>
</div>
      <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.webp" data-sizes="auto" alt="nilv" class="lazyload">
  <div class="sidebar-author-name">nilv</div>
  <div class="sidebar-description">希望你能得到些什么</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">28</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">0</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social">
  
</div>
<div class="sidebar-menu">
  
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
    
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
        <div class="sidebar-menu-icon icon rotate">
          &#xe62b;
        </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
    
  
</div>
</div>
    
  </div>
  
    <div class="sidebar-btn-wrapper">
      <div class="sidebar-toc-btn current"></div>
      <div class="sidebar-common-btn"></div>
    </div>
  
</nav>

    </div>
    
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>



<script src="/js/script.js"></script>



  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>



<script src="/js/pjax_script.js" data-pjax></script>







  
<script src="https://npm.webcache.cn/mouse-firework@0.0.6/dist/index.umd.js" integrity="sha384-vkGvf25gm1C1PbcoD5dNfc137HzNL&#x2F;hr1RKA5HniJOaawtvUmH5lTVFgFAruE9Ge" crossorigin="anonymous"></script>

  <script>
    window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["#ff5252","#ff7c7c","#ffafaf","#ffd0d0"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["#ff0000"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'))
  </script>










<div id="lazy-script">
  <div>
    
    
      
        
<script src="/js/insert_highlight.js" data-pjax></script>

      
    
    
      <script type="module" data-pjax>
        const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
        
        const pswp = () => {
          if (_$$('.article-entry a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-entry',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          if(_$$('.article-gallery a.article-gallery-item').length > 0) {
            new PhotoSwipeLightbox({
              gallery: '.article-gallery',
              children: 'a.article-gallery-item',
              pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
            }).init();
          }
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script>
      








    
  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.2.0' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  



  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>




<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>







  </body>
  <script src="/js/<file>"></script>
    <link rel="stylesheet" href="/css/<file>" />

    <canvas id="fireworks"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
    <script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="/js/fireworks.min.js"></script>

    <canvas id="background"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
    <script src="/js/background.min.js"></script>
  </html>

